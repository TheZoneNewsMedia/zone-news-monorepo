/**
 * Command Service - Handles all bot commands
 */

const config = require('../config');

class CommandService {
    constructor(bot, db) {
        this.bot = bot;
        this.db = db;
    }
    
    async register() {
        // Middleware
        this.bot.use(async (ctx, next) => {
            if (ctx.from) {
                ctx.isAdmin = config.adminIds.includes(ctx.from.id);
            }
            await next();
        });
        
        // Register commands with Telegram
        await this.registerBotCommands();
        
        // Public commands
        this.registerPublicCommands();
        
        // Admin commands
        this.registerAdminCommands();
        
        // Callback handlers
        this.registerCallbackHandlers();
        
        // Text handler
        this.registerTextHandler();
        
        // Media handler
        this.registerMediaHandler();
        
        // Error handler
        this.bot.catch((err, ctx) => {
            console.error('Bot error:', err);
            ctx.reply('âŒ An error occurred').catch(() => {});
        });
    }
    
    async registerBotCommands() {
        try {
            // Set bot commands visible in menu
            const commands = [
                { command: 'start', description: 'Start the bot' },
                { command: 'app', description: 'Open Zone News app' },
                { command: 'upgrade', description: 'Upgrade your plan' },
                { command: 'tiers', description: 'View subscription tiers' },
                { command: 'channel', description: 'Add your channel' },
                { command: 'group', description: 'Add your group' },
                { command: 'settings', description: 'Manage settings' }
            ];
            
            // Admin commands (only visible to admins)
            const adminCommands = [
                ...commands,
                { command: 'post', description: 'Post to channels' },
                { command: 'editpost', description: 'Edit recent posts' },
                { command: 'destinations', description: 'Manage destinations' },
                { command: 'analytics', description: 'View analytics' },
                { command: 'schedule', description: 'Schedule posts' },
                { command: 'broadcast', description: 'Broadcast message' }
            ];
            
            // Set default commands for all users
            await this.bot.telegram.setMyCommands(commands);
            
            // Set admin commands for admin users
            for (const adminId of config.adminIds) {
                await this.bot.telegram.setMyCommands(adminCommands, {
                    scope: { type: 'chat', chat_id: adminId }
                });
            }
            
            console.log('âœ… Bot commands registered with Telegram');
        } catch (error) {
            console.error('Failed to register commands:', error);
        }
    }
    
    registerPublicCommands() {
        // /start
        this.bot.command('start', async (ctx) => {
            // Track this user
            await this.db.collection('users').updateOne(
                { telegram_id: ctx.from.id },
                { 
                    $set: { 
                        telegram_id: ctx.from.id,
                        username: ctx.from.username,
                        first_name: ctx.from.first_name,
                        last_name: ctx.from.last_name,
                        last_active: new Date()
                    }
                },
                { upsert: true }
            );
            
            // Get actual user count
            const totalUsers = await this.db.collection('users').countDocuments();
            
            const welcomeText = 
                'ðŸŽ¯ *Welcome to Zone News Bot!*\n\n' +
                'Adelaide\'s premier automated news distribution system\n\n' +
                `ðŸ‘¥ ${totalUsers} monthly users\n\n` +
                'ðŸš€ *Features:*\n' +
                'â€¢ Auto-post to multiple channels\n' +
                'â€¢ Smart content scheduling\n' +
                'â€¢ Native Telegram reactions\n' +
                'â€¢ Analytics & insights\n' +
                'â€¢ Forward from any channel to add';
            
            const keyboard = {
                inline_keyboard: [
                    [
                        { 
                            text: 'âž• Add to Channel', 
                            url: `https://t.me/${ctx.botInfo.username}?startchannel=true` 
                        },
                        { 
                            text: 'âž• Add to Group', 
                            url: `https://t.me/${ctx.botInfo.username}?startgroup=true` 
                        }
                    ],
                    [
                        { text: 'ðŸ“° Latest News', callback_data: 'news' },
                        { text: 'ðŸ“± Mini App', web_app: { url: 'http://67.219.107.230/telegram-mini-app/' } }
                    ],
                    [
                        { text: 'ðŸ“– How to Use', callback_data: 'how_to_use' },
                        { text: 'ðŸ’¬ Support', url: 'https://t.me/ZoneNewsSupport' }
                    ],
                    ctx.isAdmin ? [{ text: 'ðŸ‘‘ Admin Panel', callback_data: 'admin' }] : []
                ].filter(row => row.length > 0)
            };
            
            await ctx.reply(welcomeText, { 
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        });
        
        // /help
        this.bot.command('help', async (ctx) => {
            let helpText = 
                'ðŸ“š *Zone News Bot Commands*\n\n' +
                '*Public Commands:*\n' +
                '/start - Welcome message\n' +
                '/help - This help menu\n' +
                '/news - View latest news\n' +
                '/status - Check bot status\n' +
                '/search - Search articles';
            
            if (ctx.isAdmin) {
                helpText += '\n\n*Admin Commands:*\n' +
                    '/post - Post to channels\n' +
                    '/destinations - Manage destinations\n' +
                    '/addchannel - Add channel\n' +
                    '/addgroup - Add group\n' +
                    '/addtopic - Add forum topic\n' +
                    '/miniapp - Open Mini App\n' +
                    '/setup - Bot configuration\n' +
                    '/broadcast - Send to all';
            }
            
            await ctx.reply(helpText, { parse_mode: 'Markdown' });
        });
        
        // /news - Personalized news based on user interactions
        this.bot.command('news', async (ctx) => {
            try {
                const userId = ctx.from.id;
                
                // Track user activity
                await this.db.collection('user_activity').updateOne(
                    { telegram_id: userId },
                    { 
                        $set: { 
                            telegram_id: userId,
                            last_active: new Date(),
                            last_command: 'news'
                        },
                        $inc: { news_views: 1 }
                    },
                    { upsert: true }
                );
                
                // Get user's interaction history for personalization
                const userProfile = await this.db.collection('user_profiles').findOne({ telegram_id: userId });
                const viewedArticles = userProfile?.viewed_articles || [];
                const preferredCategories = userProfile?.preferred_categories || [];
                
                // Fetch articles (will be AI-personalized later)
                let query = {};
                if (preferredCategories.length > 0) {
                    query.category = { $in: preferredCategories };
                }
                
                const articles = await this.db.collection('news_articles')
                    .find(query)
                    .sort({ published_date: -1 })
                    .limit(5)
                    .toArray();
                
                if (articles.length === 0) {
                    return ctx.reply('ðŸ“° No news articles available');
                }
                
                // Send personalized header
                const city = userProfile?.city || 'Adelaide';
                await ctx.reply(`ðŸ“° *Top News for ${city}*\n_Personalized for you_`, { parse_mode: 'Markdown' });
                
                for (const article of articles) {
                    // Track article view
                    await this.db.collection('article_views').insertOne({
                        user_id: userId,
                        article_id: article._id,
                        viewed_at: new Date(),
                        source: 'bot_command'
                    });
                    
                    // Update user profile with viewed article
                    await this.db.collection('user_profiles').updateOne(
                        { telegram_id: userId },
                        { 
                            $addToSet: { 
                                viewed_articles: article._id,
                                interacted_categories: article.category
                            },
                            $set: { last_news_view: new Date() }
                        },
                        { upsert: true }
                    );
                    
                    const text = this.formatArticle(article);
                    
                    // Get reaction counts
                    const reactions = article.reactions || {};
                    const likes = reactions.like || 0;
                    const loves = reactions.love || 0;
                    const fires = reactions.fire || 0;
                    
                    // Check if user has reacted
                    const userReactions = await this.db.collection('user_reactions').find({
                        user_id: userId,
                        article_id: article._id
                    }).toArray();
                    
                    const hasLiked = userReactions.some(r => r.reaction === 'like');
                    const hasLoved = userReactions.some(r => r.reaction === 'love');
                    const hasFired = userReactions.some(r => r.reaction === 'fire');
                    
                    // Add inline buttons with personalized state
                    const keyboard = {
                        inline_keyboard: [
                            [
                                { text: `${hasLiked ? 'ðŸ‘' : 'ðŸ‘'} ${likes}`, callback_data: `react:like:${article._id}` },
                                { text: `${hasLoved ? 'â¤ï¸' : 'ðŸ¤'} ${loves}`, callback_data: `react:love:${article._id}` },
                                { text: `${hasFired ? 'ðŸ”¥' : 'ðŸ”¥'} ${fires}`, callback_data: `react:fire:${article._id}` }
                            ],
                            [
                                { text: 'ðŸ’¬ Comment', callback_data: `comment:${article._id}` },
                                { text: 'ðŸ’¾ Save', callback_data: `save:${article._id}` },
                                { text: 'ðŸ”— Share', callback_data: `share:${article._id}` }
                            ]
                        ]
                    };
                    
                    await ctx.reply(text, { 
                        parse_mode: 'Markdown',
                        reply_markup: keyboard
                    });
                }
                
                // Add personalized options
                await ctx.reply('ðŸ“° *Personalized for you:*', {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'ðŸ”„ More News', callback_data: 'news:more' },
                                { text: 'ðŸŽ¯ For You', callback_data: 'news:personalized' }
                            ],
                            [
                                { text: 'ðŸ“± Open App', web_app: { url: 'http://67.219.107.230/telegram-mini-app/' } }
                            ]
                        ]
                    }
                });
            } catch (error) {
                console.error('Error fetching news:', error);
                await ctx.reply('âŒ Failed to fetch news');
            }
        });
        
        // /status
        this.bot.command('status', async (ctx) => {
            const uptime = process.uptime();
            const hours = Math.floor(uptime / 3600);
            const minutes = Math.floor((uptime % 3600) / 60);
            
            const totalArticles = await this.db.collection('news_articles').countDocuments();
            
            const statusText = 
                'ðŸ¤– *Zone News Bot Status*\n\n' +
                'âœ… Bot Online\n' +
                `â±ï¸ Uptime: ${hours}h ${minutes}m\n\n` +
                `ðŸ“Š Articles: ${totalArticles}\n` +
                `ðŸ‘‘ Admins: ${config.adminIds.length}\n\n` +
                'ðŸ’¬ @ZoneNewsBot | ðŸŒ thezonenews.com';
            
            await ctx.reply(statusText, { parse_mode: 'Markdown' });
        });
        
        // /app - Open Mini App
        this.bot.command('app', async (ctx) => {
            await ctx.reply('ðŸ“± *Zone News App*\n\nAccess the full Zone News experience', {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [{ 
                            text: 'ðŸš€ Open App', 
                            web_app: { url: 'http://67.219.107.230/telegram-mini-app/' }
                        }],
                        [
                            { text: 'ðŸ“° Latest News', callback_data: 'news' },
                            { text: 'âš™ï¸ Settings', callback_data: 'settings' }
                        ]
                    ]
                }
            });
        });
        
        // /upgrade - Upgrade subscription
        this.bot.command('upgrade', async (ctx) => {
            const upgradeText = 
                'â­ *Upgrade Your Plan*\n\n' +
                'Unlock premium features and unlimited access\n\n' +
                'ðŸ“Š Current Plan: *Free*\n' +
                'ðŸŽ¯ Available Upgrades:\n\n' +
                'â€¢ *Pro* - $9.99/month\n' +
                'â€¢ *Business* - $29.99/month\n' +
                'â€¢ *Enterprise* - Custom pricing';
            
            await ctx.reply(upgradeText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'ðŸ’Ž Pro', callback_data: 'upgrade:pro' },
                            { text: 'ðŸ¢ Business', callback_data: 'upgrade:business' }
                        ],
                        [
                            { text: 'ðŸ­ Enterprise', callback_data: 'upgrade:enterprise' }
                        ],
                        [
                            { text: 'ðŸ“‹ View Tiers', callback_data: 'tiers' }
                        ]
                    ]
                }
            });
        });
        
        // /tiers - View subscription tiers
        this.bot.command('tiers', async (ctx) => {
            const tiersText = 
                'ðŸ“Š *Subscription Tiers*\n\n' +
                'ðŸ†“ *Free Tier*\n' +
                'â€¢ 3 channels/groups\n' +
                'â€¢ 10 posts per day\n' +
                'â€¢ Basic analytics\n\n' +
                'ðŸ’Ž *Pro Tier* ($9.99/mo)\n' +
                'â€¢ 10 channels/groups\n' +
                'â€¢ 100 posts per day\n' +
                'â€¢ Advanced analytics\n' +
                'â€¢ Priority support\n\n' +
                'ðŸ¢ *Business Tier* ($29.99/mo)\n' +
                'â€¢ 50 channels/groups\n' +
                'â€¢ Unlimited posts\n' +
                'â€¢ Full analytics suite\n' +
                'â€¢ API access\n' +
                'â€¢ Dedicated support\n\n' +
                'ðŸ­ *Enterprise Tier*\n' +
                'â€¢ Unlimited everything\n' +
                'â€¢ Custom integrations\n' +
                'â€¢ SLA guarantee\n' +
                'â€¢ Account manager';
            
            await ctx.reply(tiersText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'â­ Upgrade Now', callback_data: 'upgrade' }],
                        [{ text: 'ðŸ’¬ Contact Sales', url: 'https://t.me/ZoneNewsSupport' }]
                    ]
                }
            });
        });
        
        // /channel - Add channel
        this.bot.command('channel', async (ctx) => {
            await ctx.reply(
                'ðŸ“¢ *Add Your Channel*\n\n' +
                'To add your channel:\n\n' +
                '1ï¸âƒ£ Add @ZoneNewsBot as admin\n' +
                '2ï¸âƒ£ Forward any message from your channel\n' +
                '3ï¸âƒ£ Or send the channel username\n\n' +
                'Example: @YourChannelName',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [{ 
                                text: 'âž• Add Bot to Channel', 
                                url: `https://t.me/${ctx.botInfo.username}?startchannel=true` 
                            }],
                            [{ text: 'ðŸ“– Help', callback_data: 'help:channel' }]
                        ]
                    }
                }
            );
        });
        
        // /group - Add group
        this.bot.command('group', async (ctx) => {
            await ctx.reply(
                'ðŸ‘¥ *Add Your Group*\n\n' +
                'To add your group:\n\n' +
                '1ï¸âƒ£ Add @ZoneNewsBot to your group\n' +
                '2ï¸âƒ£ Make the bot admin\n' +
                '3ï¸âƒ£ Use /setup in the group\n\n' +
                'Or forward a message from your group here',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [{ 
                                text: 'âž• Add Bot to Group', 
                                url: `https://t.me/${ctx.botInfo.username}?startgroup=true` 
                            }],
                            [{ text: 'ðŸ“– Help', callback_data: 'help:group' }]
                        ]
                    }
                }
            );
        });
        
        // /settings - User settings
        this.bot.command('settings', async (ctx) => {
            // Get user preferences
            const user = await this.db.collection('users').findOne({ telegram_id: ctx.from.id });
            const city = user?.city || 'Adelaide';
            const notifications = user?.notifications !== false;
            
            await ctx.reply(
                'âš™ï¸ *Settings*\n\n' +
                `ðŸ“ City: *${city}*\n` +
                `ðŸ”” Notifications: *${notifications ? 'On' : 'Off'}*\n` +
                `ðŸŒ Language: *English*\n` +
                `ðŸŽ¨ Theme: *Auto*`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'ðŸ“ Change City', callback_data: 'settings:city' },
                                { text: 'ðŸ”” Notifications', callback_data: 'settings:notifications' }
                            ],
                            [
                                { text: 'ðŸŒ Language', callback_data: 'settings:language' },
                                { text: 'ðŸŽ¨ Theme', callback_data: 'settings:theme' }
                            ],
                            [
                                { text: 'ðŸ‘¤ Profile', callback_data: 'settings:profile' },
                                { text: 'ðŸ—‘ï¸ Clear Data', callback_data: 'settings:clear' }
                            ]
                        ]
                    }
                }
            );
        });
        
        // /search - Search articles
        this.bot.command('search', async (ctx) => {
            const searchTerm = ctx.message.text.split(' ').slice(1).join(' ');
            
            if (!searchTerm) {
                return ctx.reply(
                    'ðŸ” *Search Articles*\n\n' +
                    'Usage: /search [keyword]\n\n' +
                    'Example: /search adelaide news',
                    { parse_mode: 'Markdown' }
                );
            }
            
            try {
                // Search in title and content
                const articles = await this.db.collection('news_articles')
                    .find({
                        $or: [
                            { title: { $regex: searchTerm, $options: 'i' } },
                            { content: { $regex: searchTerm, $options: 'i' } },
                            { summary: { $regex: searchTerm, $options: 'i' } }
                        ]
                    })
                    .sort({ published_date: -1 })
                    .limit(10)
                    .toArray();
                
                if (articles.length === 0) {
                    return ctx.reply(`ðŸ” No articles found for "${searchTerm}"`);
                }
                
                await ctx.reply(
                    `ðŸ” *Search Results for "${searchTerm}"*\n` +
                    `Found ${articles.length} article(s)\n`,
                    { parse_mode: 'Markdown' }
                );
                
                for (const article of articles.slice(0, 5)) {
                    const text = this.formatArticle(article);
                    const reactions = article.reactions || {};
                    
                    await ctx.reply(text, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    { text: `ðŸ‘ ${reactions.like || 0}`, callback_data: `react:like:${article._id}` },
                                    { text: `â¤ï¸ ${reactions.love || 0}`, callback_data: `react:love:${article._id}` },
                                    { text: `ðŸ”¥ ${reactions.fire || 0}`, callback_data: `react:fire:${article._id}` }
                                ],
                                [
                                    { text: 'ðŸ’¾ Save', callback_data: `save:${article._id}` },
                                    { text: 'ðŸ”— Share', callback_data: `share:${article._id}` }
                                ]
                            ]
                        }
                    });
                }
                
                if (articles.length > 5) {
                    await ctx.reply(
                        `\nðŸ“š Showing 5 of ${articles.length} results\n` +
                        'Use the mini app for full search',
                        {
                            reply_markup: {
                                inline_keyboard: [[
                                    { text: 'ðŸ“± Open Full Search', web_app: { url: 'http://67.219.107.230/telegram-mini-app/' } }
                                ]]
                            }
                        }
                    );
                }
            } catch (error) {
                console.error('Search error:', error);
                await ctx.reply('âŒ Search failed. Please try again.');
            }
        });
        
        // /miniapp - Open mini app
        this.bot.command('miniapp', async (ctx) => {
            await ctx.reply(
                'ðŸ“± *Zone News Mini App*\n\n' +
                'Access the full Zone News experience with advanced features',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [[
                            { text: 'ðŸš€ Open Mini App', web_app: { url: 'http://67.219.107.230/telegram-mini-app/' } }
                        ]]
                    }
                }
            );
        });
        
        // /setup - Initial bot setup
        this.bot.command('setup', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            await ctx.reply(
                'ðŸ› ï¸ *Bot Setup Wizard*\n\n' +
                'Let\'s configure your Zone News Bot:\n\n' +
                '1ï¸âƒ£ Add channels/groups\n' +
                '2ï¸âƒ£ Configure posting schedule\n' +
                '3ï¸âƒ£ Set your preferences\n' +
                '4ï¸âƒ£ Enable features\n\n' +
                'Select an option to begin:',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ðŸ“¢ Add Channel', callback_data: 'setup:channel' }],
                            [{ text: 'ðŸ‘¥ Add Group', callback_data: 'setup:group' }],
                            [{ text: 'â° Set Schedule', callback_data: 'setup:schedule' }],
                            [{ text: 'âš™ï¸ Preferences', callback_data: 'setup:preferences' }],
                            [{ text: 'âœ… Complete Setup', callback_data: 'setup:complete' }]
                        ]
                    }
                }
            );
        });
        
        // /discover - Discover trending content
        this.bot.command('discover', async (ctx) => {
            try {
                // Get trending articles based on views and reactions
                const articles = await this.db.collection('news_articles')
                    .aggregate([
                        {
                            $addFields: {
                                engagement_score: {
                                    $add: [
                                        { $ifNull: ['$views', 0] },
                                        { $multiply: [{ $ifNull: ['$reactions.like', 0] }, 2] },
                                        { $multiply: [{ $ifNull: ['$reactions.love', 0] }, 3] },
                                        { $multiply: [{ $ifNull: ['$reactions.fire', 0] }, 4] }
                                    ]
                                }
                            }
                        },
                        { $sort: { engagement_score: -1, published_date: -1 } },
                        { $limit: 10 }
                    ])
                    .toArray();
                
                if (articles.length === 0) {
                    return ctx.reply('ðŸ“° No trending articles available');
                }
                
                await ctx.reply(
                    'ðŸ”¥ *Trending on Zone News*\n\n' +
                    'Most engaging content right now:',
                    { parse_mode: 'Markdown' }
                );
                
                for (const article of articles.slice(0, 5)) {
                    const text = this.formatArticle(article);
                    const reactions = article.reactions || {};
                    
                    await ctx.reply(text, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    { text: `ðŸ‘ ${reactions.like || 0}`, callback_data: `react:like:${article._id}` },
                                    { text: `â¤ï¸ ${reactions.love || 0}`, callback_data: `react:love:${article._id}` },
                                    { text: `ðŸ”¥ ${reactions.fire || 0}`, callback_data: `react:fire:${article._id}` }
                                ],
                                [
                                    { text: 'ðŸ’¬ Comment', callback_data: `comment:${article._id}` },
                                    { text: 'ðŸ”— Share', callback_data: `share:${article._id}` }
                                ]
                            ]
                        }
                    });
                }
            } catch (error) {
                console.error('Discover error:', error);
                await ctx.reply('âŒ Failed to load trending content');
            }
        });
        
        // /settings
        this.bot.command('settings', async (ctx) => {
            const settings = await this.getUserSettings(ctx.from.id);
            
            const text = 
                'âš™ï¸ *Settings*\n\n' +
                `ðŸ”” Notifications: ${settings?.notifications ? 'On' : 'Off'}\n` +
                `ðŸŒ Language: ${settings?.language || 'English'}\n` +
                `ðŸ“° Categories: ${settings?.categories?.join(', ') || 'All'}\n\n` +
                'Select an option to change:';
            
            const keyboard = {
                inline_keyboard: [
                    [{ text: settings?.notifications ? 'ðŸ”• Disable Notifications' : 'ðŸ”” Enable Notifications', 
                       callback_data: 'toggle_notifications' }],
                    [{ text: 'ðŸ“‚ Select Categories', callback_data: 'select_categories' }],
                    [{ text: 'âŒ Close', callback_data: 'close' }]
                ]
            };
            
            await ctx.reply(text, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        });
        
        // /cancel
        this.bot.command('cancel', async (ctx) => {
            // Clear any active state
            if (this.bot.context?.botService) {
                this.bot.context.botService.clearState(ctx.from.id);
            }
            
            await ctx.reply('âŒ Operation cancelled', {
                reply_markup: { remove_keyboard: true }
            });
        });
    }
    
    registerAdminCommands() {
        // /admin
        this.bot.command('admin', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            await this.showAdminPanel(ctx);
        });
        
        // /post
        this.bot.command('post', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const destinations = await this.getDestinations();
            
            if (destinations.length === 0) {
                return ctx.reply('No destinations configured. Use /addchannel first.');
            }
            
            // Check for advanced posting options
            const args = ctx.message.text.split(' ').slice(1);
            
            if (args[0] === 'linked') {
                // Linked posting mode
                await ctx.reply(
                    'ðŸ”— *Linked Posting Mode*\n\n' +
                    'Post to a channel and auto-forward to groups with discussion link.\n\n' +
                    'Select primary channel:',
                    {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: destinations
                                .filter(d => d.type === 'channel')
                                .map(dest => [{
                                    text: `ðŸ“¢ ${dest.name || dest.id}`,
                                    callback_data: `linked_post:${dest._id}`
                                }])
                        }
                    }
                );
            } else {
                // Regular posting
                await ctx.reply('Select posting mode:', {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'ðŸ“¤ Single Destination', callback_data: 'post_single' }],
                            [{ text: 'ðŸ”— Linked Post (Channel + Groups)', callback_data: 'post_linked' }],
                            [{ text: 'ðŸ“¢ Broadcast to All', callback_data: 'post_broadcast' }],
                            [{ text: 'âŒ Cancel', callback_data: 'close' }]
                        ]
                    }
                });
            }
        });
        
        // /destinations
        this.bot.command('destinations', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const destinations = await this.getDestinations();
            
            if (destinations.length === 0) {
                return ctx.reply('No destinations configured');
            }
            
            const list = destinations.map((dest, i) => 
                `${i + 1}. ${dest.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${dest.name || dest.id}`
            ).join('\n');
            
            await ctx.reply(`ðŸ“‹ *Destinations:*\n\n${list}`, { parse_mode: 'Markdown' });
        });
        
        // /addchannel
        this.bot.command('addchannel', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const args = ctx.message.text.split(' ').slice(1);
            
            if (args.length === 0) {
                return ctx.reply(
                    'ðŸ“¢ *Add Channel*\n\n' +
                    'Usage:\n' +
                    'â€¢ `/addchannel @channelname`\n' +
                    'â€¢ `/addchannel -1001234567890` (chat ID)\n\n' +
                    'Examples:\n' +
                    'â€¢ `/addchannel @ZoneNewsAdl`\n' +
                    'â€¢ `/addchannel -1072796395391`\n\n' +
                    'ðŸ’¡ Bot must be admin in the channel!',
                    { parse_mode: 'Markdown' }
                );
            }
            
            let channelInput = args[0];
            
            // Check if it's a chat ID (negative number)
            const isChatId = /^-?\d+$/.test(channelInput);
            
            // Normalize channel input (ensure @ for usernames)
            if (!isChatId && !channelInput.startsWith('@')) {
                channelInput = '@' + channelInput;
            }
            
            // Block protected channels
            const PROTECTED_CHANNELS = ['@ZoneNewsAdl', '@ZoneNewsAdelaideA', '@ZoneNewsAdelaide'];
            const OWNER_ID = 7802629063; // Duke Exxotic
            
            if (PROTECTED_CHANNELS.includes(channelInput.toLowerCase()) && ctx.from.id !== OWNER_ID) {
                return ctx.reply(
                    'ðŸ”’ *Protected Channel*\n\n' +
                    'Sorry, this channel is not available to be posted in.\n\n' +
                    'Only the group owner can approve posting to this channel.',
                    { parse_mode: 'Markdown' }
                );
            }
            
            // Send processing message
            const processingMsg = await ctx.reply('ðŸ”„ Checking channel...');
            
            try {
                // Check if already exists by both username and ID
                const existing = await this.db.collection('destinations').findOne({
                    $or: [
                        { username: channelInput },
                        { id: channelInput }
                    ]
                });
                
                if (existing) {
                    await ctx.telegram.editMessageText(
                        ctx.chat.id,
                        processingMsg.message_id,
                        null,
                        `âš ï¸ *Channel Already Added*\n\n` +
                        `ðŸ“¢ Channel: ${existing.name || existing.username || existing.id}\n` +
                        `âœ… Status: Active\n` +
                        `ðŸ“… Added: ${new Date(existing.added_at).toLocaleDateString('en-AU')}\n\n` +
                        `Use /destinations to see all channels`,
                        { parse_mode: 'Markdown' }
                    );
                    return;
                }
                
                // Try to verify the channel exists and bot has access
                let channelInfo = null;
                let channelId = channelInput;
                let botStatus = null;
                let linkedChatId = null;
                
                try {
                    // Try to get chat info
                    const chat = await ctx.telegram.getChat(channelInput);
                    channelInfo = {
                        id: chat.id.toString(),
                        username: chat.username ? '@' + chat.username : null,
                        title: chat.title,
                        type: chat.type,
                        description: chat.description,
                        linked_chat_id: chat.linked_chat_id
                    };
                    channelId = chat.id.toString();
                    linkedChatId = chat.linked_chat_id;
                    
                    // Try to get bot member status
                    try {
                        const member = await ctx.telegram.getChatMember(chat.id, ctx.botInfo.id);
                        botStatus = member.status;
                    } catch (e) {
                        botStatus = 'not_member';
                    }
                } catch (error) {
                    console.log('Could not verify channel:', error.message);
                    
                    // Check if it's a "chat not found" error
                    if (error.description?.includes('chat not found')) {
                        await ctx.telegram.editMessageText(
                            ctx.chat.id,
                            processingMsg.message_id,
                            null,
                            `âŒ *Channel Not Found*\n\n` +
                            `Could not find channel: ${channelInput}\n\n` +
                            `Please check:\n` +
                            `1. Channel username is correct\n` +
                            `2. Channel is public or bot is member\n` +
                            `3. Use format: @channelname`,
                            { parse_mode: 'Markdown' }
                        );
                        return;
                    }
                }
                
                // Add to database
                await this.db.collection('destinations').insertOne({
                    id: channelId,
                    username: channelInfo?.username || (isChatId ? null : channelInput),
                    type: 'channel',
                    name: channelInfo?.title || channelInput,
                    description: channelInfo?.description,
                    verified: !!channelInfo,
                    bot_status: botStatus,
                    linked_chat_id: linkedChatId,
                    added_at: new Date(),
                    added_by: ctx.from.id
                });
                
                // If there's a linked discussion group, add it too
                if (linkedChatId) {
                    try {
                        const linkedChat = await ctx.telegram.getChat(linkedChatId);
                        
                        // Check if group already exists
                        const existingGroup = await this.db.collection('destinations').findOne({
                            id: linkedChatId.toString()
                        });
                        
                        if (!existingGroup) {
                            await this.db.collection('destinations').insertOne({
                                id: linkedChatId.toString(),
                                type: 'group',
                                name: linkedChat.title,
                                linked_to_channel: channelId,
                                verified: true,
                                added_at: new Date(),
                                added_by: ctx.from.id,
                                auto_added: true
                            });
                        }
                    } catch (err) {
                        console.log('Could not add linked discussion group:', err.message);
                    }
                }
                
                // Prepare success message based on bot status
                let statusEmoji = 'âœ…';
                let statusText = 'Ready';
                let instructions = '';
                
                if (botStatus === 'administrator') {
                    statusEmoji = 'âœ…';
                    statusText = 'Bot is admin - Ready to post!';
                } else if (botStatus === 'member') {
                    statusEmoji = 'âš ï¸';
                    statusText = 'Bot is member but not admin';
                    instructions = '\n\n*Action Required:*\nPromote bot to admin with "Post Messages" permission';
                } else if (botStatus === 'not_member' || !botStatus) {
                    statusEmoji = 'âš ï¸';
                    statusText = 'Bot not in channel';
                    instructions = '\n\n*Action Required:*\n1. Add @ZoneNewsBot to channel\n2. Make bot admin\n3. Grant "Post Messages" permission';
                }
                
                // Send detailed success message
                let successMessage = 
                    `${statusEmoji} *Channel Added Successfully!*\n\n` +
                    `ðŸ“¢ *Channel Details:*\n` +
                    `â€¢ Name: ${channelInfo?.title || channelInput}\n` +
                    `â€¢ Username: ${channelInfo?.username || 'ID: ' + channelId}\n` +
                    `â€¢ ID: \`${channelId}\`\n` +
                    `â€¢ Type: ${channelInfo?.type || 'channel'}\n`;
                
                if (linkedChatId) {
                    successMessage += `â€¢ ðŸ’¬ Linked Group: Added automatically\n`;
                }
                
                successMessage += 
                    `\nðŸ¤– *Bot Status:* ${statusText}` +
                    instructions +
                    `\n\nðŸ“ Use /post to send news to this channel`;
                
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    processingMsg.message_id,
                    null,
                    successMessage,
                    { parse_mode: 'Markdown' }
                );
                
                // Test post if bot is admin
                if (botStatus === 'administrator') {
                    try {
                        const testMsg = await ctx.telegram.sendMessage(
                            channelId,
                            'âœ… Zone News Bot connected successfully!\n\nThis is a test message to confirm the bot can post to this channel.',
                            { disable_notification: true }
                        );
                        
                        // Delete test message after 5 seconds
                        setTimeout(() => {
                            ctx.telegram.deleteMessage(channelId, testMsg.message_id).catch(() => {});
                        }, 5000);
                        
                        await ctx.reply('âœ… Test message sent and will be deleted in 5 seconds');
                    } catch (error) {
                        console.log('Could not send test message:', error.message);
                    }
                }
            } catch (error) {
                console.error('Error adding channel:', error);
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    processingMsg.message_id,
                    null,
                    `âŒ *Failed to Add Channel*\n\n` +
                    `Error: ${error.message || 'Unknown error'}\n\n` +
                    `Please try again or contact support`,
                    { parse_mode: 'Markdown' }
                );
            }
        });
        
        // /editpost - Edit recent posts (Telegram allows editing messages up to 48 hours old)
        this.bot.command('editpost', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            // Get posts from last 48 hours (Telegram's edit limit)
            const twoDaysAgo = new Date();
            twoDaysAgo.setHours(twoDaysAgo.getHours() - 48);
            
            const recentPosts = await this.db.collection('posted_articles')
                .find({ 
                    posted_at: { $gte: twoDaysAgo },
                    posted_by: ctx.from.id
                })
                .sort({ posted_at: -1 })
                .limit(10)
                .toArray();
            
            if (recentPosts.length === 0) {
                return ctx.reply(
                    'ðŸ“ *No Editable Posts*\n\n' +
                    'No posts found in the last 48 hours.\n\n' +
                    '_Note: Telegram only allows editing messages up to 48 hours old._',
                    { parse_mode: 'Markdown' }
                );
            }
            
            await ctx.reply(
                'ðŸ“ *Edit Recent Posts*\n\n' +
                'Select a post to edit (last 48 hours only):',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: recentPosts.map(post => [{
                            text: `ðŸ“° ${post.title || 'Post'} - ${new Date(post.posted_at).toLocaleString('en-AU')}`,
                            callback_data: `edit_post:${post._id}`
                        }])
                    }
                }
            );
        });
        
        // /analytics - View analytics
        this.bot.command('analytics', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            // Get analytics data
            const [totalUsers, activeUsers, totalPosts, totalViews, topCategories] = await Promise.all([
                this.db.collection('users').countDocuments(),
                this.db.collection('user_activity').countDocuments({
                    last_active: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
                }),
                this.db.collection('posted_articles').countDocuments(),
                this.db.collection('article_views').countDocuments(),
                this.db.collection('user_profiles').aggregate([
                    { $unwind: '$interacted_categories' },
                    { $group: { _id: '$interacted_categories', count: { $sum: 1 } } },
                    { $sort: { count: -1 } },
                    { $limit: 5 }
                ]).toArray()
            ]);
            
            const analyticsText = 
                'ðŸ“Š *Analytics Dashboard*\n\n' +
                '*User Metrics:*\n' +
                `ðŸ‘¥ Total Users: ${totalUsers}\n` +
                `ðŸŸ¢ Active (30d): ${activeUsers}\n\n` +
                '*Content Metrics:*\n' +
                `ðŸ“° Total Posts: ${totalPosts}\n` +
                `ðŸ‘ Total Views: ${totalViews}\n\n` +
                '*Top Categories:*\n' +
                topCategories.map((cat, i) => `${i + 1}. ${cat._id}: ${cat.count} interactions`).join('\n');
            
            await ctx.reply(analyticsText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'ðŸ“ˆ Detailed Stats', callback_data: 'analytics:detailed' },
                            { text: 'ðŸ“… Weekly Report', callback_data: 'analytics:weekly' }
                        ],
                        [
                            { text: 'ðŸ’° Revenue', callback_data: 'analytics:revenue' },
                            { text: 'ðŸ“Š Export CSV', callback_data: 'analytics:export' }
                        ]
                    ]
                }
            });
        });
        
        // /schedule - Schedule posts
        this.bot.command('schedule', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            // Get scheduled posts
            const scheduledPosts = await this.db.collection('scheduled_posts')
                .find({ 
                    scheduled_for: { $gte: new Date() },
                    status: 'pending'
                })
                .sort({ scheduled_for: 1 })
                .limit(10)
                .toArray();
            
            let scheduleText = 'ðŸ“… *Scheduled Posts*\n\n';
            
            if (scheduledPosts.length > 0) {
                scheduleText += '*Upcoming Posts:*\n';
                scheduledPosts.forEach((post, i) => {
                    const time = new Date(post.scheduled_for).toLocaleString('en-AU');
                    scheduleText += `${i + 1}. ${post.title} - ${time}\n`;
                });
                scheduleText += '\n';
            } else {
                scheduleText += '_No scheduled posts_\n\n';
            }
            
            scheduleText += 'Select an action:';
            
            await ctx.reply(scheduleText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'âž• Schedule New', callback_data: 'schedule:new' },
                            { text: 'ðŸ“‹ View All', callback_data: 'schedule:view' }
                        ],
                        [
                            { text: 'â° Set Auto-Post', callback_data: 'schedule:auto' },
                            { text: 'ðŸ—‘ï¸ Clear Queue', callback_data: 'schedule:clear' }
                        ]
                    ]
                }
            });
        });
        
        // /destinations - Manage destinations
        this.bot.command('destinations', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const destinations = await this.db.collection('destinations').find({}).toArray();
            
            if (destinations.length === 0) {
                return ctx.reply(
                    'ðŸ“ *No Destinations*\n\n' +
                    'You haven\'t added any channels or groups yet.\n\n' +
                    'Use:\n' +
                    'â€¢ /channel - Add a channel\n' +
                    'â€¢ /group - Add a group',
                    { parse_mode: 'Markdown' }
                );
            }
            
            // Group by type
            const channels = destinations.filter(d => d.type === 'channel');
            const groups = destinations.filter(d => d.type === 'group');
            const forums = destinations.filter(d => d.type === 'forum');
            
            let destText = 'ðŸ“ *Your Destinations*\n\n';
            
            if (channels.length > 0) {
                destText += '*ðŸ“¢ Channels:*\n';
                channels.forEach(ch => {
                    const status = ch.bot_status === 'administrator' ? 'âœ…' : 'âš ï¸';
                    destText += `${status} ${ch.name || ch.username || ch.id}\n`;
                });
                destText += '\n';
            }
            
            if (groups.length > 0) {
                destText += '*ðŸ‘¥ Groups:*\n';
                groups.forEach(gr => {
                    const status = gr.bot_status === 'administrator' ? 'âœ…' : 'âš ï¸';
                    destText += `${status} ${gr.name || gr.id}\n`;
                });
                destText += '\n';
            }
            
            if (forums.length > 0) {
                destText += '*ðŸ’¬ Forum Topics:*\n';
                forums.forEach(f => {
                    destText += `â€¢ ${f.name} (Topic ${f.topic_id})\n`;
                });
            }
            
            await ctx.reply(destText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'âž• Add Channel', callback_data: 'add:channel' },
                            { text: 'âž• Add Group', callback_data: 'add:group' }
                        ],
                        [
                            { text: 'ðŸ—‘ï¸ Remove', callback_data: 'destinations:remove' },
                            { text: 'ðŸ”„ Refresh', callback_data: 'destinations:refresh' }
                        ]
                    ]
                }
            });
        });
        
        // /addgroup
        this.bot.command('addgroup', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const args = ctx.message.text.split(' ').slice(1);
            
            // If argument provided, add by ID
            if (args.length > 0) {
                const groupId = args[0];
                
                // Check if it's a valid group ID (negative number)
                if (!/^-\d+$/.test(groupId)) {
                    return ctx.reply(
                        'âŒ Invalid group ID\n\n' +
                        'Usage:\n' +
                        'â€¢ `/addgroup -1001234567890`\n' +
                        'â€¢ Use /addgroup in a group without ID'
                    );
                }
                
                try {
                    const chat = await ctx.telegram.getChat(groupId);
                    
                    // Check if already exists
                    const existing = await this.db.collection('destinations').findOne({
                        id: chat.id.toString()
                    });
                    
                    if (existing) {
                        return ctx.reply(`âš ï¸ Group "${chat.title}" is already added`);
                    }
                    
                    // Add to database
                    await this.db.collection('destinations').insertOne({
                        id: chat.id.toString(),
                        type: chat.is_forum ? 'forum' : 'group',
                        name: chat.title,
                        description: chat.description,
                        is_forum: chat.is_forum,
                        verified: true,
                        added_at: new Date(),
                        added_by: ctx.from.id
                    });
                    
                    await ctx.reply(
                        `âœ… *Group Added Successfully!*\n\n` +
                        `ðŸ‘¥ Name: ${chat.title}\n` +
                        `ðŸ†” ID: \`${chat.id}\`\n` +
                        `ðŸ“ Type: ${chat.is_forum ? 'Forum' : 'Group'}`,
                        { parse_mode: 'Markdown' }
                    );
                } catch (error) {
                    await ctx.reply(
                        `âŒ Failed to add group\n\n` +
                        `Make sure:\n` +
                        `1. The ID is correct\n` +
                        `2. Bot is a member of the group`
                    );
                }
                return;
            }
            
            // Original behavior - add current group
            if (ctx.chat.type === 'private') {
                return ctx.reply(
                    'ðŸ‘¥ *Add Group*\n\n' +
                    'Usage:\n' +
                    'â€¢ `/addgroup` (use in a group)\n' +
                    'â€¢ `/addgroup -1001234567890` (by ID)\n\n' +
                    'Examples:\n' +
                    'â€¢ `/addgroup -1072796395391`',
                    { parse_mode: 'Markdown' }
                );
            }
            
            const destData = {
                id: ctx.chat.id.toString(),
                type: ctx.chat.is_forum ? 'forum' : 'group',
                name: ctx.chat.title,
                added_at: new Date()
            };
            
            // For forums, store the general topic ID (1)
            if (ctx.chat.is_forum) {
                destData.is_forum = true;
                destData.default_thread_id = 1; // General topic
            }
            
            await this.db.collection('destinations').insertOne(destData);
            
            await ctx.reply(`âœ… ${ctx.chat.is_forum ? 'Forum' : 'Group'} added`);
        });
        
        // /addtopic
        this.bot.command('addtopic', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            // Check if in a forum
            if (!ctx.chat?.is_forum) {
                return ctx.reply('This command can only be used in forum groups');
            }
            
            const topicId = ctx.message?.message_thread_id;
            
            if (!topicId) {
                return ctx.reply('Please use this command inside a forum topic');
            }
            
            try {
                // Get or create forum destination
                let forum = await this.db.collection('destinations').findOne({
                    id: ctx.chat.id.toString(),
                    type: 'forum'
                });
                
                if (!forum) {
                    // Create forum entry first
                    await this.db.collection('destinations').insertOne({
                        id: ctx.chat.id.toString(),
                        type: 'forum',
                        name: ctx.chat.title,
                        is_forum: true,
                        topics: [{
                            id: topicId,
                            name: `Topic ${topicId}`,
                            added_at: new Date()
                        }],
                        added_at: new Date(),
                        added_by: ctx.from.id
                    });
                    
                    await ctx.reply(`âœ… Forum and topic added successfully!`);
                } else {
                    // Add topic to existing forum
                    const topics = forum.topics || [];
                    
                    if (topics.find(t => t.id === topicId)) {
                        return ctx.reply('âš ï¸ This topic is already added');
                    }
                    
                    await this.db.collection('destinations').updateOne(
                        { _id: forum._id },
                        { 
                            $push: { 
                                topics: {
                                    id: topicId,
                                    name: `Topic ${topicId}`,
                                    added_at: new Date()
                                }
                            }
                        }
                    );
                    
                    await ctx.reply(`âœ… Topic added to ${ctx.chat.title}`);
                }
            } catch (error) {
                console.error('Error adding topic:', error);
                await ctx.reply('âŒ Failed to add topic');
            }
        });
        
        // /removedestination
        this.bot.command('removedestination', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const destinations = await this.getDestinations();
            
            if (destinations.length === 0) {
                return ctx.reply('No destinations to remove');
            }
            
            const keyboard = {
                inline_keyboard: destinations.map(dest => [{
                    text: `ðŸ—‘ï¸ ${dest.name || dest.id}`,
                    callback_data: `remove_dest:${dest._id}`
                }])
            };
            
            keyboard.inline_keyboard.push([{ text: 'âŒ Cancel', callback_data: 'close' }]);
            
            await ctx.reply('Select destination to remove:', {
                reply_markup: keyboard
            });
        });
        
        // /setup
        this.bot.command('setup', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const keyboard = {
                inline_keyboard: [
                    [{ text: 'ðŸ“¢ Add Channels', callback_data: 'setup_channels' }],
                    [{ text: 'ðŸ‘¥ Manage Admins', callback_data: 'setup_admins' }],
                    [{ text: 'â° Configure Schedules', callback_data: 'setup_schedules' }],
                    [{ text: 'ðŸ” Discover Channels', callback_data: 'setup_discover' }],
                    [{ text: 'âŒ Exit Setup', callback_data: 'close' }]
                ]
            };
            
            await ctx.reply(
                'ðŸš€ *Zone News Bot Setup*\n\n' +
                'Configure your bot settings:\n\n' +
                'What would you like to set up?',
                { 
                    parse_mode: 'Markdown', 
                    reply_markup: keyboard 
                }
            );
        });
        
        // /discover
        this.bot.command('discover', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            await ctx.reply(
                'ðŸ” *Discovering Channels & Groups*\n\n' +
                'Scanning for places where bot is admin...',
                { parse_mode: 'Markdown' }
            );
            
            // This would need actual implementation to discover channels
            await ctx.reply(
                'âŒ Auto-discovery requires additional permissions.\n\n' +
                'Please add channels manually using:\n' +
                'â€¢ /addchannel @channel\n' +
                'â€¢ /addgroup (in group)'
            );
        });
        
        // /schedule
        this.bot.command('schedule', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const parts = ctx.message.text.split(' ');
            
            if (parts.length < 3) {
                return ctx.reply(
                    'â° *Schedule Post*\n\n' +
                    'Usage: /schedule [time] [destination]\n\n' +
                    '*Time Formats:*\n' +
                    'â€¢ `14:30` - Today at 2:30 PM\n' +
                    'â€¢ `tomorrow 09:00` - Tomorrow at 9 AM\n' +
                    'â€¢ `daily 10:00` - Every day at 10 AM\n\n' +
                    'Example: /schedule daily 09:00 @ZoneNewsAdl',
                    { parse_mode: 'Markdown' }
                );
            }
            
            // Store schedule in database
            await this.db.collection('scheduled_posts').insertOne({
                user_id: ctx.from.id,
                schedule: parts[1],
                destination: parts[2],
                created_at: new Date(),
                active: true
            });
            
            await ctx.reply('âœ… Schedule created successfully');
        });
        
        // /addtopic
        this.bot.command('addtopic', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const args = ctx.message.text.split(' ').slice(1);
            
            if (args.length < 2) {
                return ctx.reply(
                    'ðŸ“ *Add Forum Topic*\n\n' +
                    'Usage: /addtopic [forum_id] [topic_id]\n\n' +
                    'Example: /addtopic -1001234567890 123\n\n' +
                    'To find topic ID:\n' +
                    '1. Right-click topic in forum\n' +
                    '2. Copy link\n' +
                    '3. The number after last / is topic ID',
                    { parse_mode: 'Markdown' }
                );
            }
            
            const [forumId, topicId] = args;
            
            await this.db.collection('forum_topics').insertOne({
                forum_id: forumId,
                topic_id: parseInt(topicId),
                name: `Topic ${topicId}`,
                added_at: new Date(),
                added_by: ctx.from.id
            });
            
            await ctx.reply(`âœ… Topic ${topicId} added to forum ${forumId}`);
        });
        
        // /listtopics
        this.bot.command('listtopics', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const topics = await this.db.collection('forum_topics').find({}).toArray();
            
            if (topics.length === 0) {
                return ctx.reply('No forum topics configured');
            }
            
            const list = topics.map((topic, i) => 
                `${i + 1}. Forum: ${topic.forum_id}\n   â””â”€ Topic: ${topic.topic_id} (${topic.name})`
            ).join('\n\n');
            
            await ctx.reply(`ðŸ“‹ *Forum Topics:*\n\n${list}`, { parse_mode: 'Markdown' });
        });
        
        // /posttotopic
        this.bot.command('posttotopic', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const args = ctx.message.text.split(' ').slice(1);
            
            if (args.length < 3) {
                return ctx.reply(
                    'ðŸ“® *Post to Forum Topic*\n\n' +
                    'Usage: /posttotopic [forum_id] [topic_id] [message]\n\n' +
                    'Example: /posttotopic -1001234567890 123 Hello topic!',
                    { parse_mode: 'Markdown' }
                );
            }
            
            const [forumId, topicId, ...messageParts] = args;
            const message = messageParts.join(' ');
            
            try {
                await this.bot.telegram.sendMessage(forumId, message, {
                    message_thread_id: parseInt(topicId),
                    parse_mode: 'Markdown'
                });
                
                await ctx.reply('âœ… Message sent to topic');
            } catch (err) {
                await ctx.reply(`âŒ Failed: ${err.message}`);
            }
        });
        
        // /broadcast - Safe broadcast with confirmation
        this.bot.command('broadcast', async (ctx) => {
            if (!ctx.isAdmin) {
                return ctx.reply('âš ï¸ Admin access required');
            }
            
            const message = ctx.message.text.split(' ').slice(1).join(' ');
            
            if (!message) {
                return ctx.reply(
                    'ðŸ“¢ *Broadcast Message*\n\n' +
                    'Usage: /broadcast [message]\n\n' +
                    'Safety features:\n' +
                    'â€¢ Requires confirmation\n' +
                    'â€¢ Batch processing\n' +
                    'â€¢ Rate limited',
                    { parse_mode: 'Markdown' }
                );
            }
            
            // Get all users for broadcast
            const users = await this.db.collection('users')
                .find({})
                .toArray();
            
            const userCount = users.length;
            
            if (userCount === 0) {
                return ctx.reply('ðŸ“¢ No users to broadcast to');
            }
            
            // Store broadcast for confirmation
            const broadcastId = `broadcast_${Date.now()}`;
            await this.db.collection('pending_broadcasts').insertOne({
                id: broadcastId,
                admin_id: ctx.from.id,
                message: message,
                user_count: userCount,
                created_at: new Date(),
                status: 'pending'
            });
            
            await ctx.reply(
                `ðŸ“¢ *Broadcast Confirmation Required*\n\n` +
                `Recipients: ${userCount} users\n` +
                `Message preview:\n\n${message.substring(0, 300)}${message.length > 300 ? '...' : ''}\n\n` +
                `âš ï¸ This action cannot be undone.`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: `âœ… Send to ${userCount} users`, callback_data: `broadcast_confirm:${broadcastId}` },
                                { text: 'âŒ Cancel', callback_data: 'broadcast_cancel' }
                            ]
                        ]
                    }
                }
        });
    }
    
    registerCallbackHandlers() {
        this.bot.on('callback_query', async (ctx) => {
            const data = ctx.callbackQuery.data;
            await ctx.answerCbQuery();
            
            // Handle reaction callbacks
            if (data.startsWith('react:')) {
                const [_, reactionType, articleId] = data.split(':');
                await this.handleReaction(ctx, reactionType, articleId);
                return;
            }
            
            // Handle save callback
            else if (data.startsWith('save:')) {
                const articleId = data.split(':')[1];
                await this.handleSave(ctx, articleId);
                return;
            }
            
            // Handle share callback  
            else if (data.startsWith('share:')) {
                const articleId = data.split(':')[1];
                await this.handleShare(ctx, articleId);
                return;
            }
            
            // Handle comment callback
            else if (data.startsWith('comment:')) {
                await ctx.answerCbQuery('ðŸ’¬ Comments feature coming soon!', { show_alert: true });
                return;
            }
            
            // Handle quick add callback
            else if (data.startsWith('quick_add:')) {
                const [_, chatId, chatType] = data.split(':');
                await this.quickAddDestination(ctx, chatId, chatType);
                return;
            }
            
            // Handle auto add callback
            else if (data.startsWith('auto_add:')) {
                const [_, chatId, chatType, ...titleParts] = data.split(':');
                const title = titleParts.join(':');
                await this.autoAddDestination(ctx, chatId, chatType, title);
                return;
            }
            
            // Handle status check callback
            else if (data.startsWith('check_status:')) {
                const chatId = data.split(':')[1];
                await this.checkBotStatus(ctx, chatId);
                return;
            }
            
            // Handle scheduling callbacks
            else if (data.startsWith('schedule:')) {
                const action = data.split(':')[1];
                await this.handleScheduleCallback(ctx, action);
                return;
            }
            
            // Handle media callbacks
            else if (data.startsWith('media:')) {
                const [_, action, fileId] = data.split(':');
                await this.handleMediaCallback(ctx, action, fileId);
                return;
            }
            
            // Handle attach media callback
            else if (data.startsWith('attach_media:')) {
                const [_, fileId, articleId] = data.split(':');
                await this.attachMediaToArticle(ctx, fileId, articleId);
                return;
            }
            
            // Handle settings callbacks
            else if (data.startsWith('settings:')) {
                const setting = data.split(':')[1];
                await this.handleSettingsCallback(ctx, setting);
                return;
            }
            
            // Handle save article callback
            else if (data.startsWith('save:')) {
                const articleId = data.split(':')[1];
                await this.saveArticle(ctx, articleId);
                return;
            }
            
            // Handle share callback
            else if (data.startsWith('share:')) {
                const articleId = data.split(':')[1];
                await this.shareArticle(ctx, articleId);
                return;
            }
            
            // Handle comment callback
            else if (data.startsWith('comment:')) {
                const articleId = data.split(':')[1];
                await this.handleComment(ctx, articleId);
                return;
            }
            
            // Handle how to use callback
            else if (data === 'how_to_use') {
                await ctx.editMessageText(
                    'ðŸ“– *How to Use Zone News Bot*\n\n' +
                    '*For Channel/Group Owners:*\n' +
                    '1ï¸âƒ£ Add @ZoneNewsBot to your channel/group\n' +
                    '2ï¸âƒ£ Make the bot an admin\n' +
                    '3ï¸âƒ£ Send any of these to register:\n' +
                    '   â€¢ Forward a message from your channel\n' +
                    '   â€¢ Send your channel link (@username)\n' +
                    '   â€¢ Use /addchannel or /addgroup\n\n' +
                    '*Quick Add Methods:*\n' +
                    'â€¢ Forward any message â†’ Auto-detect\n' +
                    'â€¢ Send @channelname â†’ Quick lookup\n' +
                    'â€¢ Send t.me/channel â†’ Parse link\n' +
                    'â€¢ Use chat ID: /addchannel -1001234567890\n\n' +
                    '*Posting News:*\n' +
                    'â€¢ /post - Start posting wizard\n' +
                    'â€¢ Choose single or linked posting\n' +
                    'â€¢ Select your articles\n' +
                    'â€¢ Auto-forward with reactions\n\n' +
                    '*Need Help?*\n' +
                    '@ZoneNewsSupport',
                    { 
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [[
                                { text: 'Â« Back', callback_data: 'start' }
                            ]]
                        }
                    }
                );
                return;
            }
            
            // Handle start callback (go back to start)
            else if (data === 'start') {
                // Re-run start command logic
                const [totalUsers, totalChannels, totalGroups, totalArticles] = await Promise.all([
                    this.db.collection('users').countDocuments(),
                    this.db.collection('destinations').countDocuments({ type: 'channel' }),
                    this.db.collection('destinations').countDocuments({ type: { $in: ['group', 'forum'] } }),
                    this.db.collection('news_articles').countDocuments()
                ]);
                
                const monthlyUsers = 3; // Simplified for now
                
                await ctx.editMessageText(
                    'ðŸŽ¯ *Welcome to Zone News Bot!*\n\n' +
                    'Adelaide\'s premier automated news distribution system\n\n' +
                    'ðŸ“Š *Statistics:*\n' +
                    `ðŸ‘¥ ${monthlyUsers} monthly users\n` +
                    `ðŸ“¢ ${totalChannels} channels connected\n` +
                    `ðŸ‘¥ ${totalGroups} groups active\n` +
                    `ðŸ“° ${totalArticles.toLocaleString()} articles shared\n\n` +
                    'ðŸš€ *Features:*\n' +
                    'â€¢ Auto-post to multiple channels\n' +
                    'â€¢ Smart content scheduling\n' +
                    'â€¢ Native Telegram reactions\n' +
                    'â€¢ Analytics & insights\n' +
                    'â€¢ Forward from any channel to add',
                    {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    { 
                                        text: 'âž• Add to Channel', 
                                        url: `https://t.me/${ctx.botInfo.username}?startchannel=true` 
                                    },
                                    { 
                                        text: 'âž• Add to Group', 
                                        url: `https://t.me/${ctx.botInfo.username}?startgroup=true` 
                                    }
                                ],
                                [
                                    { text: 'ðŸ“° Latest News', callback_data: 'news' },
                                    { text: 'ðŸ“± Mini App', web_app: { url: 'http://67.219.107.230/telegram-mini-app/' } }
                                ],
                                [
                                    { text: 'ðŸ“– How to Use', callback_data: 'how_to_use' },
                                    { text: 'ðŸ’¬ Support', url: 'https://t.me/ZoneNewsSupport' }
                                ],
                                ctx.isAdmin ? [{ text: 'ðŸ‘‘ Admin Panel', callback_data: 'admin' }] : []
                            ].filter(row => row.length > 0)
                        }
                    }
                );
                return;
            }
            
            // Basic callbacks
            if (data === 'news') {
                await this.sendLatestNews(ctx);
            } else if (data === 'search') {
                await ctx.reply('Enter your search term:');
                // Set state for search
                this.bot.context?.botService?.setState(ctx.from.id, { 
                    action: 'search',
                    step: 'waiting_for_term'
                });
            } else if (data === 'admin' && ctx.isAdmin) {
                await this.showAdminPanel(ctx);
            } else if (data === 'close') {
                await ctx.deleteMessage();
            } else if (data === 'post' && ctx.isAdmin) {
                // Start post workflow
                await this.startPostWorkflow(ctx);
            } else if (data === 'destinations' && ctx.isAdmin) {
                // Show destinations
                const destinations = await this.getDestinations();
                if (destinations.length === 0) {
                    await ctx.editMessageText('No destinations configured. Use /addchannel or /addgroup first.');
                } else {
                    const list = destinations.map((dest, i) => 
                        `${i + 1}. ${dest.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${dest.name || dest.id}`
                    ).join('\n');
                    await ctx.editMessageText(`ðŸ“‹ *Destinations:*\n\n${list}`, { parse_mode: 'Markdown' });
                }
            }
            
            // Setup callbacks
            else if (data === 'setup_channels') {
                await ctx.editMessageText(
                    'ðŸ“¢ *Add Channels*\n\n' +
                    'To add a channel:\n' +
                    '1. Add the bot as admin to your channel\n' +
                    '2. Use /addchannel @channelname\n\n' +
                    'Or use /discover to auto-find channels',
                    { parse_mode: 'Markdown' }
                );
            } else if (data === 'setup_admins') {
                await ctx.editMessageText(
                    'ðŸ‘¥ *Manage Admins*\n\n' +
                    'Current admin commands:\n' +
                    'â€¢ /addchannel - Add a channel\n' +
                    'â€¢ /addgroup - Add a group\n' +
                    'â€¢ /removedestination - Remove destination\n' +
                    'â€¢ /broadcast - Send to all destinations',
                    { parse_mode: 'Markdown' }
                );
            } else if (data === 'setup_schedules') {
                await ctx.editMessageText(
                    'â° *Configure Schedules*\n\n' +
                    '/schedule [time] [destination]\n\n' +
                    'Examples:\n' +
                    'â€¢ /schedule daily 09:00 @channel\n' +
                    'â€¢ /schedule tomorrow 14:30 @channel',
                    { parse_mode: 'Markdown' }
                );
            } else if (data === 'setup_discover') {
                await ctx.editMessageText(
                    'ðŸ” *Channel Discovery*\n\n' +
                    'Use /discover to find channels where the bot is admin',
                    { parse_mode: 'Markdown' }
                );
            }
            
            // Posting mode selection
            else if (data === 'post_single') {
                const destinations = await this.getDestinations();
                await ctx.editMessageText('Select destination:', {
                    reply_markup: {
                        inline_keyboard: destinations.map(dest => [{
                            text: `${dest.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${dest.name || dest.id}`,
                            callback_data: `dest:${dest._id}`
                        }])
                    }
                });
            }
            
            else if (data === 'post_linked') {
                const destinations = await this.getDestinations();
                const channels = destinations.filter(d => d.type === 'channel');
                
                if (channels.length === 0) {
                    await ctx.editMessageText('No channels configured. Add a channel first with /addchannel');
                    return;
                }
                
                await ctx.editMessageText(
                    'ðŸ”— *Linked Posting*\n\n' +
                    'This will:\n' +
                    '1. Post to a channel\n' +
                    '2. Forward to selected groups\n' +
                    '3. Add "Join Channel" button\n\n' +
                    'Select primary channel:',
                    {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: channels.map(ch => [{
                                text: `ðŸ“¢ ${ch.name || ch.id}`,
                                callback_data: `linked_channel:${ch._id}`
                            }])
                        }
                    }
                );
            }
            
            else if (data.startsWith('linked_channel:')) {
                const channelId = data.split(':')[1];
                // Store channel and show group selection
                if (this.bot.context?.botService) {
                    this.bot.context.botService.setState(ctx.from.id, {
                        action: 'linked_post',
                        channel_id: channelId,
                        step: 'select_groups'
                    });
                }
                
                const destinations = await this.getDestinations();
                const groups = destinations.filter(d => d.type === 'group' || d.type === 'forum');
                
                await ctx.editMessageText(
                    'ðŸ‘¥ Select groups to forward to:',
                    {
                        reply_markup: {
                            inline_keyboard: [
                                ...groups.map(g => [{
                                    text: `â˜ ${g.name || g.id}`,
                                    callback_data: `toggle_group:${g._id}`
                                }]),
                                [{ text: 'âœ… Continue', callback_data: 'linked_continue' }],
                                [{ text: 'âŒ Cancel', callback_data: 'close' }]
                            ]
                        }
                    }
                );
            }
            
            else if (data.startsWith('toggle_group:')) {
                const groupId = data.split(':')[1];
                const state = this.bot.context?.botService?.getState(ctx.from.id);
                
                if (state) {
                    state.selected_groups = state.selected_groups || [];
                    const index = state.selected_groups.indexOf(groupId);
                    
                    if (index > -1) {
                        state.selected_groups.splice(index, 1);
                    } else {
                        state.selected_groups.push(groupId);
                    }
                    
                    // Update keyboard to show selection
                    const destinations = await this.getDestinations();
                    const groups = destinations.filter(d => d.type === 'group' || d.type === 'forum');
                    
                    await ctx.editMessageReplyMarkup({
                        inline_keyboard: [
                            ...groups.map(g => [{
                                text: `${state.selected_groups.includes(g._id.toString()) ? 'â˜‘' : 'â˜'} ${g.name || g.id}`,
                                callback_data: `toggle_group:${g._id}`
                            }]),
                            [{ text: 'âœ… Continue', callback_data: 'linked_continue' }],
                            [{ text: 'âŒ Cancel', callback_data: 'close' }]
                        ]
                    });
                }
            }
            
            else if (data === 'linked_continue') {
                const state = this.bot.context?.botService?.getState(ctx.from.id);
                if (state && state.selected_groups?.length > 0) {
                    // Show article selection
                    await this.showArticleSelectionForLinked(ctx, state);
                } else {
                    await ctx.answerCbQuery('Please select at least one group', { show_alert: true });
                }
            }
            
            // Destination selection for posting
            else if (data.startsWith('dest:')) {
                const destId = data.split(':')[1];
                // Show article selection
                await this.showArticleSelection(ctx, destId);
            }
            
            // Linked article selection
            else if (data.startsWith('linked_article:')) {
                const articleId = data.split(':')[1];
                const state = this.bot.context?.botService?.getState(ctx.from.id);
                
                if (state && state.channel_id && state.selected_groups) {
                    await ctx.editMessageText('ðŸ”„ Posting to channel and forwarding to groups...');
                    await this.postLinkedContent(ctx, articleId, state.channel_id, state.selected_groups);
                    this.bot.context.botService.clearState(ctx.from.id);
                }
            }
            
            // Article selection for posting
            else if (data.startsWith('post_article:')) {
                const [, destId, articleId] = data.split(':');
                await this.postArticleToDestination(ctx, destId, articleId);
            }
            
            // Post latest news
            else if (data.startsWith('post_latest:')) {
                const destId = data.split(':')[1];
                await this.postLatestToDestination(ctx, destId);
            }
            
            // Post custom message
            else if (data.startsWith('post_custom:')) {
                const destId = data.split(':')[1];
                await ctx.editMessageText('ðŸ“ Enter your custom message:');
                // Set state for custom message
                if (this.bot.context?.botService) {
                    this.bot.context.botService.setState(ctx.from.id, {
                        action: 'post_custom',
                        destination_id: destId,
                        step: 'waiting_for_message'
                    });
                }
            }
            
            // Destination removal
            else if (data.startsWith('remove_dest:')) {
                const destId = data.split(':')[1];
                try {
                    const { ObjectId } = require('mongodb');
                    await this.db.collection('destinations').deleteOne({
                        _id: new ObjectId(destId)
                    });
                    await ctx.editMessageText('âœ… Destination removed successfully');
                } catch (err) {
                    await ctx.editMessageText('âŒ Failed to remove destination');
                }
            }
            
            // Reaction callbacks
            else if (data.startsWith('like_') || data.startsWith('love_') || data.startsWith('fire_')) {
                const [reaction, articleId, currentCount] = data.split('_');
                const newCount = parseInt(currentCount) + 1;
                
                // Update reaction count in database
                await this.db.collection('article_reactions').updateOne(
                    { article_id: articleId, reaction: reaction },
                    { 
                        $inc: { count: 1 },
                        $addToSet: { users: ctx.from.id }
                    },
                    { upsert: true }
                );
                
                // Update button text
                const keyboard = ctx.callbackQuery.message.reply_markup;
                if (keyboard && keyboard.inline_keyboard) {
                    for (const row of keyboard.inline_keyboard) {
                        for (const button of row) {
                            if (button.callback_data === data) {
                                const emoji = reaction === 'like' ? 'ðŸ‘' : reaction === 'love' ? 'â¤ï¸' : 'ðŸ”¥';
                                button.text = `${emoji} ${newCount}`;
                                button.callback_data = `${reaction}_${articleId}_${newCount}`;
                            }
                        }
                    }
                    
                    await ctx.editMessageReplyMarkup(keyboard);
                }
                
                await ctx.answerCbQuery(`You ${reaction}d this article!`);
                return; // Don't continue to other handlers
            }
            
            // Settings callbacks
            else if (data === 'settings_menu') {
                const settings = await this.getUserSettings(ctx.from.id);
                
                const text = 
                    'âš™ï¸ *Settings*\n\n' +
                    `ðŸ”” Notifications: ${settings?.notifications ? 'On' : 'Off'}\n` +
                    `ðŸŒ Language: ${settings?.language || 'English'}\n` +
                    `ðŸ“° Categories: ${settings?.categories?.join(', ') || 'All'}\n\n` +
                    'Select an option to change:';
                
                const keyboard = {
                    inline_keyboard: [
                        [{ text: settings?.notifications ? 'ðŸ”• Disable Notifications' : 'ðŸ”” Enable Notifications', 
                           callback_data: 'toggle_notifications' }],
                        [{ text: 'ðŸ“‚ Select Categories', callback_data: 'select_categories' }],
                        [{ text: 'ðŸ“± Mini App Settings', web_app: { url: 'https://thezonenews.com/telegram-mini-app' } }],
                        [{ text: 'âŒ Close', callback_data: 'close' }]
                    ]
                };
                
                await ctx.editMessageText(text, {
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            }
            else if (data === 'toggle_notifications') {
                const userId = ctx.from.id;
                const settings = await this.getUserSettings(userId);
                await this.db.collection('user_settings').updateOne(
                    { user_id: userId },
                    { $set: { notifications: !settings?.notifications } },
                    { upsert: true }
                );
                await ctx.answerCbQuery('âœ… Settings updated');
                // Refresh settings display
                ctx.callbackQuery.message.text = '/settings';
                await this.bot.handleUpdate(ctx.update);
            } else if (data === 'select_categories') {
                await ctx.editMessageText(
                    'ðŸ“‚ *Select Categories*\n\n' +
                    'Feature coming soon!',
                    { parse_mode: 'Markdown' }
                );
            }
        });
    }
    
    registerTextHandler() {
        // Handle text for interactive flows
        this.bot.on('text', async (ctx) => {
            if (!ctx.from) return;
            
            // Check if it's a channel/group link or username
            const text = ctx.message.text;
            const channelRegex = /(?:https?:\/\/)?(?:t\.me|telegram\.me)\/([a-zA-Z0-9_]+)|@([a-zA-Z0-9_]+)/;
            const match = text.match(channelRegex);
            
            if (match && ctx.isAdmin) {
                const username = match[1] || match[2];
                await this.handleQuickAdd(ctx, username);
                return;
            }
            
            if (!this.bot.context?.botService) return;
            
            const state = this.bot.context.botService.getState(ctx.from.id);
            if (!state) return;
            
            // Handle search
            if (state.action === 'search' && state.step === 'waiting_for_term') {
                await this.performSearch(ctx, ctx.message.text);
                this.bot.context.botService.clearState(ctx.from.id);
            }
            
            // Handle custom post message
            else if (state.action === 'post_custom' && state.step === 'waiting_for_message') {
                const destination = await this.db.collection('destinations').findOne({
                    _id: new (require('mongodb').ObjectId)(state.destination_id)
                });
                
                if (destination) {
                    try {
                        await this.bot.telegram.sendMessage(destination.id, ctx.message.text, {
                            parse_mode: 'Markdown'
                        });
                        await ctx.reply('âœ… Message posted successfully!');
                    } catch (err) {
                        await ctx.reply(`âŒ Failed to post: ${err.message}`);
                    }
                }
                
                this.bot.context.botService.clearState(ctx.from.id);
            }
        });
        
        // Handle forwarded messages for auto-detection
        this.bot.on('forward_date', async (ctx) => {
            if (!ctx.isAdmin) return;
            
            const forwardFrom = ctx.message.forward_from_chat;
            if (!forwardFrom) return;
            
            await this.handleForwardedChannel(ctx, forwardFrom);
        });
    }
    
    // Helper methods
    async sendLatestNews(ctx) {
        try {
            const articles = await this.db.collection('news_articles')
                .find({})
                .sort({ published_date: -1 })
                .limit(5)
                .toArray();
            
            if (articles.length === 0) {
                return ctx.reply('ðŸ“° No news articles available');
            }
            
            for (const article of articles) {
                const text = this.formatArticle(article);
                
                // Create inline keyboard with reactions and actions
                const keyboard = {
                    inline_keyboard: [
                        [
                            { text: 'ðŸ‘ 0', callback_data: `like_${article._id}_0` },
                            { text: 'â¤ï¸ 0', callback_data: `love_${article._id}_0` },
                            { text: 'ðŸ”¥ 0', callback_data: `fire_${article._id}_0` }
                        ],
                        [
                            { text: 'ðŸ“– Read More', url: article.url || `https://thezonenews.com/article/${article._id}` },
                            { text: 'ðŸ”— Share', url: `https://t.me/share/url?url=${encodeURIComponent(article.url || 'https://thezonenews.com')}` }
                        ]
                    ]
                };
                
                // Get existing reaction counts
                const reactions = await this.db.collection('article_reactions')
                    .find({ article_id: article._id.toString() })
                    .toArray();
                
                // Update reaction counts in keyboard
                for (const reaction of reactions) {
                    const buttonIndex = reaction.reaction === 'like' ? 0 : reaction.reaction === 'love' ? 1 : 2;
                    const emoji = reaction.reaction === 'like' ? 'ðŸ‘' : reaction.reaction === 'love' ? 'â¤ï¸' : 'ðŸ”¥';
                    keyboard.inline_keyboard[0][buttonIndex].text = `${emoji} ${reaction.count || 0}`;
                    keyboard.inline_keyboard[0][buttonIndex].callback_data = `${reaction.reaction}_${article._id}_${reaction.count || 0}`;
                }
                
                await ctx.reply(text, { 
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            }
            
            // Add navigation buttons at the end
            const navKeyboard = {
                inline_keyboard: [
                    [
                        { text: 'ðŸ”„ Refresh News', callback_data: 'news' },
                        { text: 'ðŸ“± Open Mini App', web_app: { url: 'https://thezonenews.com/telegram-mini-app' } }
                    ],
                    [
                        { text: 'ðŸ” Search Articles', callback_data: 'search' },
                        { text: 'âš™ï¸ Settings', callback_data: 'settings_menu' }
                    ]
                ]
            };
            
            await ctx.reply('ðŸ“° *More options:*', {
                parse_mode: 'Markdown',
                reply_markup: navKeyboard
            });
            
        } catch (error) {
            console.error('Error fetching news:', error);
            await ctx.reply('âŒ Failed to fetch news');
        }
    }
    
    async performSearch(ctx, searchTerm) {
        try {
            const articles = await this.db.collection('news_articles')
                .find({
                    $or: [
                        { title: { $regex: searchTerm, $options: 'i' } },
                        { content: { $regex: searchTerm, $options: 'i' } }
                    ]
                })
                .limit(5)
                .toArray();
            
            if (articles.length === 0) {
                return ctx.reply(`No articles found for "${searchTerm}"`);
            }
            
            let resultsText = `ðŸ” *Search Results:*\n\n`;
            articles.forEach((article, i) => {
                resultsText += `${i + 1}. ${article.title}\n`;
            });
            
            await ctx.reply(resultsText, { parse_mode: 'Markdown' });
        } catch (error) {
            console.error('Search error:', error);
            await ctx.reply('âŒ Search failed');
        }
    }
    
    async showAdminPanel(ctx) {
        const text = 'ðŸ‘‘ *Admin Panel*\n\nSelect an action:';
        
        const keyboard = {
            inline_keyboard: [
                [{ text: 'ðŸ“ Post Article', callback_data: 'post' }],
                [{ text: 'ðŸ“¢ Destinations', callback_data: 'destinations' }],
                [{ text: 'âŒ Close', callback_data: 'close' }]
            ]
        };
        
        await ctx.reply(text, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    
    async getDestinations() {
        return await this.db.collection('destinations').find({}).toArray();
    }
    
    async startPostWorkflow(ctx) {
        const destinations = await this.getDestinations();
        
        if (destinations.length === 0) {
            return ctx.editMessageText('No destinations configured. Use /addchannel or /addgroup first.');
        }
        
        const keyboard = {
            inline_keyboard: destinations.map(dest => [{
                text: `${dest.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${dest.name || dest.id}`,
                callback_data: `dest:${dest._id}`
            }])
        };
        
        keyboard.inline_keyboard.push([{ text: 'âŒ Cancel', callback_data: 'close' }]);
        
        await ctx.editMessageText('ðŸ“® Select destination for posting:', {
            reply_markup: keyboard
        });
    }
    
    async showArticleSelection(ctx, destId) {
        // Get latest articles
        const articles = await this.db.collection('news_articles')
            .find({})
            .sort({ published_date: -1 })
            .limit(5)
            .toArray();
        
        if (articles.length === 0) {
            return ctx.editMessageText('No articles available to post');
        }
        
        const keyboard = {
            inline_keyboard: [
                [{ 
                    text: 'ðŸ“° Post Latest Article', 
                    callback_data: `post_latest:${destId}` 
                }],
                ...articles.slice(0, 3).map(article => [{
                    text: `ðŸ“„ ${article.title.substring(0, 30)}...`,
                    callback_data: `post_article:${destId}:${article._id}`
                }]),
                [{ 
                    text: 'âœï¸ Custom Message', 
                    callback_data: `post_custom:${destId}` 
                }],
                [{ text: 'âŒ Cancel', callback_data: 'close' }]
            ]
        };
        
        await ctx.editMessageText('ðŸ“ Select what to post:', {
            reply_markup: keyboard
        });
    }
    
    async postArticleToDestination(ctx, destId, articleId) {
        try {
            const { ObjectId } = require('mongodb');
            
            const destination = await this.db.collection('destinations').findOne({
                _id: new ObjectId(destId)
            });
            
            const article = await this.db.collection('news_articles').findOne({
                _id: new ObjectId(articleId)
            });
            
            if (!destination || !article) {
                return ctx.editMessageText('âŒ Destination or article not found');
            }
            
            const message = this.formatArticle(article);
            const options = { parse_mode: 'Markdown' };
            
            // Handle forum topics
            if (destination.is_forum && destination.default_thread_id) {
                options.message_thread_id = destination.default_thread_id;
            }
            
            await this.bot.telegram.sendMessage(destination.id, message, options);
            
            await ctx.editMessageText(
                `âœ… Posted successfully!\n\n` +
                `ðŸ“° Article: ${article.title}\n` +
                `ðŸ“ Destination: ${destination.name || destination.id}`
            );
            
        } catch (error) {
            await ctx.editMessageText(`âŒ Failed to post: ${error.message}`);
        }
    }
    
    async postLatestToDestination(ctx, destId) {
        try {
            const { ObjectId } = require('mongodb');
            
            const destination = await this.db.collection('destinations').findOne({
                _id: new ObjectId(destId)
            });
            
            const article = await this.db.collection('news_articles')
                .findOne({}, { sort: { published_date: -1 } });
            
            if (!destination || !article) {
                return ctx.editMessageText('âŒ No articles available or destination not found');
            }
            
            const message = this.formatArticle(article);
            const options = { parse_mode: 'Markdown' };
            
            // Handle forum topics
            if (destination.is_forum && destination.default_thread_id) {
                options.message_thread_id = destination.default_thread_id;
            }
            
            await this.bot.telegram.sendMessage(destination.id, message, options);
            
            await ctx.editMessageText(
                `âœ… Latest article posted!\n\n` +
                `ðŸ“° ${article.title}\n` +
                `ðŸ“ ${destination.name || destination.id}`
            );
            
        } catch (error) {
            await ctx.editMessageText(`âŒ Failed to post: ${error.message}`);
        }
    }
    
    async getUserSettings(userId) {
        return await this.db.collection('user_settings').findOne({ user_id: userId });
    }
    
    formatArticle(article) {
        const date = new Date(article.published_date).toLocaleDateString('en-AU', {
            day: 'numeric',
            month: 'short'
        });
        
        return `ðŸ“° *${article.title}*\n\n` +
               `${article.summary || article.content?.substring(0, 200)}...\n\n` +
               `ðŸ“… ${date} | ðŸ“‚ ${article.category || 'General'}\n` +
               `ðŸ‘ ${article.views || 0} views`;
    }
    
    async handleReaction(ctx, reactionType, articleId) {
        const userId = ctx.from.id;
        
        try {
            // Check if user already reacted
            const existingReaction = await this.db.collection('user_reactions').findOne({
                user_id: userId,
                article_id: articleId,
                reaction: reactionType
            });
            
            if (existingReaction) {
                // Remove reaction
                await this.db.collection('user_reactions').deleteOne({
                    user_id: userId,
                    article_id: articleId,
                    reaction: reactionType
                });
                
                // Decrement count
                await this.db.collection('news_articles').updateOne(
                    { _id: new (require('mongodb').ObjectId)(articleId) },
                    { $inc: { [`reactions.${reactionType}`]: -1 } }
                );
                
                await ctx.answerCbQuery(`Removed ${reactionType} reaction`);
            } else {
                // Add reaction
                await this.db.collection('user_reactions').insertOne({
                    user_id: userId,
                    article_id: articleId,
                    reaction: reactionType,
                    created_at: new Date()
                });
                
                // Increment count
                await this.db.collection('news_articles').updateOne(
                    { _id: new (require('mongodb').ObjectId)(articleId) },
                    { $inc: { [`reactions.${reactionType}`]: 1 } }
                );
                
                await ctx.answerCbQuery(`Added ${reactionType} reaction!`);
            }
            
            // Update the message with new counts
            await this.updateReactionButtons(ctx, articleId);
        } catch (error) {
            console.error('Error handling reaction:', error);
            await ctx.answerCbQuery('Failed to update reaction', { show_alert: true });
        }
    }
    
    async handleSave(ctx, articleId) {
        const userId = ctx.from.id;
        
        try {
            // Check if already saved
            const saved = await this.db.collection('saved_articles').findOne({
                user_id: userId,
                article_id: articleId
            });
            
            if (saved) {
                await this.db.collection('saved_articles').deleteOne({
                    user_id: userId,
                    article_id: articleId
                });
                await ctx.answerCbQuery('Removed from saved articles');
            } else {
                await this.db.collection('saved_articles').insertOne({
                    user_id: userId,
                    article_id: articleId,
                    saved_at: new Date()
                });
                await ctx.answerCbQuery('âœ… Article saved!');
            }
        } catch (error) {
            console.error('Error saving article:', error);
            await ctx.answerCbQuery('Failed to save article', { show_alert: true });
        }
    }
    
    async handleShare(ctx, articleId) {
        const shareUrl = `https://thezonenews.com/article/${articleId}`;
        await ctx.answerCbQuery();
        await ctx.reply(
            `ðŸ”— Share this article:\n${shareUrl}\n\n` +
            `Or use the button below:`,
            {
                reply_markup: {
                    inline_keyboard: [[
                        { 
                            text: 'ðŸ“¤ Share on Telegram', 
                            url: `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}` 
                        }
                    ]]
                }
            }
        );
    }
    
    async updateReactionButtons(ctx, articleId) {
        try {
            // Get updated article with reaction counts
            const article = await this.db.collection('news_articles').findOne({
                _id: new (require('mongodb').ObjectId)(articleId)
            });
            
            if (!article) return;
            
            const reactions = article.reactions || {};
            const likes = reactions.like || 0;
            const loves = reactions.love || 0;
            const fires = reactions.fire || 0;
            
            // Update inline keyboard
            const newKeyboard = {
                inline_keyboard: [
                    [
                        { text: `ðŸ‘ ${likes}`, callback_data: `react:like:${articleId}` },
                        { text: `â¤ï¸ ${loves}`, callback_data: `react:love:${articleId}` },
                        { text: `ðŸ”¥ ${fires}`, callback_data: `react:fire:${articleId}` }
                    ],
                    [
                        { text: 'ðŸ’¬ Comment', callback_data: `comment:${articleId}` },
                        { text: 'ðŸ’¾ Save', callback_data: `save:${articleId}` },
                        { text: 'ðŸ”— Share', callback_data: `share:${articleId}` }
                    ]
                ]
            };
            
            await ctx.editMessageReplyMarkup(newKeyboard);
        } catch (error) {
            console.error('Error updating reaction buttons:', error);
        }
    }
    
    async showArticleSelectionForLinked(ctx, state) {
        // Get latest articles
        const articles = await this.db.collection('news_articles')
            .find({})
            .sort({ published_date: -1 })
            .limit(5)
            .toArray();
        
        if (articles.length === 0) {
            return ctx.editMessageText('No articles available to post');
        }
        
        await ctx.editMessageText(
            'ðŸ“° Select article to post:',
            {
                reply_markup: {
                    inline_keyboard: articles.map(article => [{
                        text: `ðŸ“„ ${article.title.substring(0, 40)}...`,
                        callback_data: `linked_article:${article._id}`
                    }])
                }
            }
        );
    }
    
    async handleQuickAdd(ctx, username) {
        // Send processing message
        const processingMsg = await ctx.reply(
            'ðŸ” Detecting channel/group...\n\n' +
            `Looking up: @${username}`
        );
        
        try {
            // Try to get chat info
            const chat = await ctx.telegram.getChat('@' + username);
            
            // Check if already exists
            const existing = await this.db.collection('destinations').findOne({
                $or: [
                    { id: chat.id.toString() },
                    { username: '@' + username }
                ]
            });
            
            if (existing) {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    processingMsg.message_id,
                    null,
                    `âœ… *Already Added*\n\n` +
                    `${chat.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${chat.title}\n` +
                    `Username: @${username}\n` +
                    `Type: ${chat.type}`,
                    { parse_mode: 'Markdown' }
                );
                return;
            }
            
            // Add inline keyboard for confirmation
            await ctx.telegram.editMessageText(
                ctx.chat.id,
                processingMsg.message_id,
                null,
                `ðŸ” *Found ${chat.type === 'channel' ? 'Channel' : 'Group'}*\n\n` +
                `ðŸ“Œ Name: ${chat.title}\n` +
                `ðŸ‘¤ Username: @${username}\n` +
                `ðŸ†” ID: \`${chat.id}\`\n` +
                `ðŸ“ Type: ${chat.type}\n` +
                `${chat.description ? `ðŸ“„ Description: ${chat.description.substring(0, 100)}...\n` : ''}\n` +
                `Would you like to add this ${chat.type}?`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'âœ… Add', callback_data: `quick_add:${chat.id}:${chat.type}` },
                                { text: 'âŒ Cancel', callback_data: 'close' }
                            ]
                        ]
                    }
                }
            );
        } catch (error) {
            await ctx.telegram.editMessageText(
                ctx.chat.id,
                processingMsg.message_id,
                null,
                `âŒ Could not find @${username}\n\n` +
                `Make sure:\n` +
                `â€¢ The username is correct\n` +
                `â€¢ It's a public channel/group\n` +
                `â€¢ Or use /addchannel with chat ID`
            );
        }
    }
    
    async handleForwardedChannel(ctx, forwardFrom) {
        // Check if already exists
        const existing = await this.db.collection('destinations').findOne({
            id: forwardFrom.id.toString()
        });
        
        if (existing) {
            await ctx.reply(
                `âœ… *Already Added*\n\n` +
                `${forwardFrom.type === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${forwardFrom.title}\n` +
                `Type: ${forwardFrom.type}\n` +
                `Added: ${new Date(existing.added_at).toLocaleDateString('en-AU')}`,
                { parse_mode: 'Markdown' }
            );
            return;
        }
        
        // Show info with add button
        await ctx.reply(
            `ðŸŽ¯ *Auto-Detected from Forward*\n\n` +
            `${forwardFrom.type === 'channel' ? 'ðŸ“¢ Channel' : 'ðŸ‘¥ Group'}: ${forwardFrom.title}\n` +
            `ðŸ†” ID: \`${forwardFrom.id}\`\n` +
            `${forwardFrom.username ? `ðŸ‘¤ @${forwardFrom.username}\n` : ''}\n` +
            `Would you like to add this ${forwardFrom.type}?`,
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'âœ… Add to Bot', callback_data: `auto_add:${forwardFrom.id}:${forwardFrom.type}:${forwardFrom.title}` }
                        ],
                        [
                            { text: 'ðŸ” Check Bot Status', callback_data: `check_status:${forwardFrom.id}` }
                        ],
                        [
                            { text: 'âŒ Cancel', callback_data: 'close' }
                        ]
                    ]
                }
            }
        );
    }
    
    async postLinkedContent(ctx, articleId, channelDestId, groupDestIds) {
        try {
            const article = await this.db.collection('news_articles').findOne({
                _id: new (require('mongodb').ObjectId)(articleId)
            });
            
            if (!article) {
                await ctx.reply('Article not found');
                return;
            }
            
            // Get channel destination
            const channel = await this.db.collection('destinations').findOne({
                _id: new (require('mongodb').ObjectId)(channelDestId)
            });
            
            if (!channel) {
                await ctx.reply('Channel not found');
                return;
            }
            
            // Format the message
            const message = this.formatArticle(article);
            
            // Create keyboard with reactions and join button
            const channelUsername = channel.username || channel.id;
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: `ðŸ‘ 0`, callback_data: `react:like:${articleId}` },
                        { text: `â¤ï¸ 0`, callback_data: `react:love:${articleId}` },
                        { text: `ðŸ”¥ 0`, callback_data: `react:fire:${articleId}` }
                    ],
                    [
                        { text: 'ðŸ“¢ Join Channel', url: `https://t.me/${channelUsername.replace('@', '')}` },
                        { text: 'ðŸ’¬ Discuss', url: `https://t.me/${channelUsername.replace('@', '')}` }
                    ],
                    [
                        { text: 'ðŸ”— Share', callback_data: `share:${articleId}` },
                        { text: 'ðŸ’¾ Save', callback_data: `save:${articleId}` }
                    ]
                ]
            };
            
            // Post to channel first
            const channelPost = await ctx.telegram.sendMessage(
                channel.id,
                message + '\n\nðŸ‘ Views: Will update with native Telegram counter',
                {
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                }
            );
            
            // Forward to each selected group
            for (const groupId of groupDestIds) {
                const group = await this.db.collection('destinations').findOne({
                    _id: new (require('mongodb').ObjectId)(groupId)
                });
                
                if (group) {
                    try {
                        // Forward the message to preserve views counter
                        await ctx.telegram.forwardMessage(
                            group.id,
                            channel.id,
                            channelPost.message_id
                        );
                        
                        // Send a follow-up with interactive buttons
                        await ctx.telegram.sendMessage(
                            group.id,
                            `ðŸ’¬ *Discussion for above post*\n\n` +
                            `React and discuss here!`,
                            {
                                parse_mode: 'Markdown',
                                reply_markup: {
                                    inline_keyboard: [
                                        [
                                            { text: `ðŸ‘ Like`, callback_data: `react:like:${articleId}` },
                                            { text: `â¤ï¸ Love`, callback_data: `react:love:${articleId}` },
                                            { text: `ðŸ”¥ Fire`, callback_data: `react:fire:${articleId}` }
                                        ],
                                        [
                                            { text: 'ðŸ“¢ Join Channel', url: `https://t.me/${channelUsername.replace('@', '')}` },
                                            { text: 'ðŸ”— Share', url: `https://t.me/share/url?url=${encodeURIComponent(`https://t.me/${channelUsername.replace('@', '')}/${channelPost.message_id}`)}` }
                                        ]
                                    ]
                                }
                            }
                        );
                    } catch (error) {
                        console.error(`Failed to forward to group ${group.name}:`, error.message);
                    }
                }
            }
            
            // Store posting record
            await this.db.collection('posted_articles').insertOne({
                article_id: articleId,
                channel_id: channelDestId,
                channel_message_id: channelPost.message_id,
                forwarded_to: groupDestIds,
                posted_at: new Date(),
                posted_by: ctx.from.id
            });
            
            await ctx.reply(
                `âœ… *Posted Successfully!*\n\n` +
                `ðŸ“¢ Channel: ${channel.name}\n` +
                `ðŸ‘¥ Forwarded to: ${groupDestIds.length} groups\n` +
                `ðŸ‘ Native Telegram views enabled\n` +
                `ðŸ’¬ Discussion links added`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Error in linked posting:', error);
            await ctx.reply(`âŒ Failed to post: ${error.message}`);
        }
    }
    
    async quickAddDestination(ctx, chatId, chatType) {
        try {
            await this.db.collection('destinations').insertOne({
                id: chatId,
                type: chatType,
                verified: true,
                added_at: new Date(),
                added_by: ctx.from.id,
                added_via: 'quick_add'
            });
            
            await ctx.editMessageText(
                `âœ… Successfully added ${chatType}!\n\n` +
                `Use /destinations to view all destinations\n` +
                `Use /post to start posting`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            await ctx.editMessageText(`âŒ Failed to add: ${error.message}`);
        }
    }
    
    async autoAddDestination(ctx, chatId, chatType, title) {
        try {
            await this.db.collection('destinations').insertOne({
                id: chatId,
                type: chatType,
                name: title,
                verified: true,
                added_at: new Date(),
                added_by: ctx.from.id,
                added_via: 'forward'
            });
            
            await ctx.editMessageText(
                `âœ… *Successfully Added!*\n\n` +
                `${chatType === 'channel' ? 'ðŸ“¢' : 'ðŸ‘¥'} ${title}\n` +
                `ðŸ†” ID: \`${chatId}\`\n\n` +
                `You can now post to this ${chatType} using /post`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            await ctx.editMessageText(`âŒ Failed to add: ${error.message}`);
        }
    }
    
    async checkBotStatus(ctx, chatId) {
        try {
            const member = await ctx.telegram.getChatMember(chatId, ctx.botInfo.id);
            const statusEmoji = member.status === 'administrator' ? 'âœ…' : 'âš ï¸';
            
            await ctx.answerCbQuery(
                `${statusEmoji} Bot is ${member.status} in this chat`,
                { show_alert: true }
            );
        } catch (error) {
            await ctx.answerCbQuery(
                'âŒ Bot is not in this chat',
                { show_alert: true }
            );
        }
    }
    
    async handleScheduleCallback(ctx, action) {
        try {
            await ctx.answerCbQuery();
            
            switch (action) {
                case 'new':
                    await this.showScheduleNewPost(ctx);
                    break;
                case 'view':
                    await this.showScheduledPosts(ctx);
                    break;
                case 'auto':
                    await this.showAutoPostSettings(ctx);
                    break;
                case 'clear':
                    await this.clearScheduledPosts(ctx);
                    break;
                default:
                    if (action.startsWith('cancel_')) {
                        const postId = action.replace('cancel_', '');
                        await this.cancelScheduledPost(ctx, postId);
                    } else if (action.startsWith('article_')) {
                        const articleId = action.replace('article_', '');
                        await this.scheduleArticle(ctx, articleId);
                    } else if (action.startsWith('time_')) {
                        const [articleId, time] = action.replace('time_', '').split('_');
                        await this.confirmSchedule(ctx, articleId, time);
                    }
                    break;
            }
        } catch (error) {
            console.error('Schedule callback error:', error);
            await ctx.editMessageText('âŒ An error occurred');
        }
    }
    
    async showScheduleNewPost(ctx) {
        // Get recent articles
        const articles = await this.db.collection('news_articles')
            .find({})
            .sort({ published_date: -1 })
            .limit(10)
            .toArray();
        
        if (articles.length === 0) {
            return ctx.editMessageText('ðŸ“° No articles available to schedule');
        }
        
        await ctx.editMessageText(
            'ðŸ“… *Schedule New Post*\n\nSelect an article to schedule:',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: articles.map(article => [{
                        text: `ðŸ“° ${article.title.substring(0, 40)}...`,
                        callback_data: `schedule:article_${article._id}`
                    }])
                }
            }
        );
    }
    
    async scheduleArticle(ctx, articleId) {
        // Show time selection
        const now = new Date();
        const timeOptions = [
            { label: 'In 30 minutes', minutes: 30 },
            { label: 'In 1 hour', minutes: 60 },
            { label: 'In 2 hours', minutes: 120 },
            { label: 'In 4 hours', minutes: 240 },
            { label: 'Tomorrow 9 AM', minutes: this.getMinutesUntilTime(9, 0) },
            { label: 'Tomorrow 12 PM', minutes: this.getMinutesUntilTime(12, 0) },
            { label: 'Tomorrow 6 PM', minutes: this.getMinutesUntilTime(18, 0) }
        ];
        
        await ctx.editMessageText(
            'â° *Select Schedule Time*\n\nWhen should this post be published?',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: timeOptions.map(option => [{
                        text: option.label,
                        callback_data: `schedule:time_${articleId}_${option.minutes}`
                    }])
                }
            }
        );
    }
    
    async confirmSchedule(ctx, articleId, minutes) {
        const { ObjectId } = require('mongodb');
        const scheduledFor = new Date();
        scheduledFor.setMinutes(scheduledFor.getMinutes() + parseInt(minutes));
        
        // Get destinations
        const destinations = await this.db.collection('destinations').find({}).toArray();
        
        if (destinations.length === 0) {
            return ctx.editMessageText('ðŸ“ No destinations configured. Add channels/groups first.');
        }
        
        // For now, schedule to all destinations (could add selection later)
        const destIds = destinations.map(d => d._id.toString());
        
        // Create scheduled post
        const result = await this.db.collection('scheduled_posts').insertOne({
            article_id: articleId,
            destinations: destIds,
            scheduled_for: scheduledFor,
            scheduled_by: ctx.from.id,
            created_at: new Date(),
            status: 'pending'
        });
        
        await ctx.editMessageText(
            'âœ… *Post Scheduled!*\n\n' +
            `ðŸ“… Will be posted on: ${scheduledFor.toLocaleString('en-AU')}\n` +
            `ðŸ“ To ${destinations.length} destination(s)\n\n` +
            'Use /schedule to manage scheduled posts',
            { parse_mode: 'Markdown' }
        );
    }
    
    async showScheduledPosts(ctx) {
        const posts = await this.db.collection('scheduled_posts')
            .find({ 
                status: 'pending',
                scheduled_for: { $gte: new Date() }
            })
            .sort({ scheduled_for: 1 })
            .toArray();
        
        if (posts.length === 0) {
            return ctx.editMessageText('ðŸ“… No scheduled posts');
        }
        
        let text = 'ðŸ“… *All Scheduled Posts*\n\n';
        const buttons = [];
        
        for (const post of posts) {
            const article = await this.db.collection('news_articles')
                .findOne({ _id: new ObjectId(post.article_id) });
            
            const time = new Date(post.scheduled_for).toLocaleString('en-AU');
            text += `â€¢ ${article?.title || 'Unknown'}\n  â° ${time}\n\n`;
            
            buttons.push([{
                text: `âŒ Cancel: ${article?.title?.substring(0, 20)}...`,
                callback_data: `schedule:cancel_${post._id}`
            }]);
        }
        
        await ctx.editMessageText(text, {
            parse_mode: 'Markdown',
            reply_markup: { inline_keyboard: buttons }
        });
    }
    
    async showAutoPostSettings(ctx) {
        await ctx.editMessageText(
            'â° *Auto-Posting Settings*\n\n' +
            'Configure automatic posting schedule:\n\n' +
            'â€¢ Morning (9 AM daily)\n' +
            'â€¢ Afternoon (2 PM daily)\n' +
            'â€¢ Evening (6 PM daily)\n' +
            'â€¢ Every 4 hours\n' +
            'â€¢ Weekdays only\n\n' +
            '_Select a schedule to enable auto-posting_',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'ðŸŒ… Morning (9 AM)', callback_data: 'auto:morning' }],
                        [{ text: 'â˜€ï¸ Afternoon (2 PM)', callback_data: 'auto:afternoon' }],
                        [{ text: 'ðŸŒ† Evening (6 PM)', callback_data: 'auto:evening' }],
                        [{ text: 'â±ï¸ Every 4 hours', callback_data: 'auto:4hours' }],
                        [{ text: 'ðŸ’¼ Weekdays only', callback_data: 'auto:weekdays' }]
                    ]
                }
            }
        );
    }
    
    async clearScheduledPosts(ctx) {
        const result = await this.db.collection('scheduled_posts').updateMany(
            { status: 'pending', scheduled_by: ctx.from.id },
            { $set: { status: 'cancelled', cancelled_at: new Date() } }
        );
        
        await ctx.editMessageText(
            `âœ… Cleared ${result.modifiedCount} scheduled posts`,
            { parse_mode: 'Markdown' }
        );
    }
    
    async cancelScheduledPost(ctx, postId) {
        const { ObjectId } = require('mongodb');
        
        await this.db.collection('scheduled_posts').updateOne(
            { _id: new ObjectId(postId) },
            { $set: { status: 'cancelled', cancelled_at: new Date() } }
        );
        
        await ctx.editMessageText('âœ… Scheduled post cancelled');
    }
    
    getMinutesUntilTime(hour, minute) {
        const now = new Date();
        const target = new Date();
        target.setDate(target.getDate() + 1);
        target.setHours(hour, minute, 0, 0);
        
        return Math.floor((target - now) / 60000);
    }
    
    registerMediaHandler() {
        const MediaService = require('./media-service');
        this.mediaService = new MediaService(this.bot, this.db);
        
        // Handle photo messages
        this.bot.on('photo', async (ctx) => {
            if (!ctx.isAdmin) return;
            await this.mediaService.handleMediaMessage(ctx);
        });
        
        // Handle video messages
        this.bot.on('video', async (ctx) => {
            if (!ctx.isAdmin) return;
            await this.mediaService.handleMediaMessage(ctx);
        });
        
        // Handle document messages
        this.bot.on('document', async (ctx) => {
            if (!ctx.isAdmin) return;
            await this.mediaService.handleMediaMessage(ctx);
        });
        
        // Handle animation (GIF) messages
        this.bot.on('animation', async (ctx) => {
            if (!ctx.isAdmin) return;
            await this.mediaService.handleMediaMessage(ctx);
        });
        
        // Handle audio messages
        this.bot.on('audio', async (ctx) => {
            if (!ctx.isAdmin) return;
            await this.mediaService.handleMediaMessage(ctx);
        });
    }
    
    async handleMediaCallback(ctx, action, fileId) {
        try {
            await ctx.answerCbQuery();
            
            switch (action) {
                case 'article':
                    await this.showArticleSelectionForMedia(ctx, fileId);
                    break;
                case 'post':
                    await this.postMediaNow(ctx, fileId);
                    break;
                case 'schedule':
                    await this.scheduleMediaPost(ctx, fileId);
                    break;
                case 'save':
                    await this.saveMediaForLater(ctx, fileId);
                    break;
                case 'delete':
                    await this.deleteMedia(ctx, fileId);
                    break;
            }
        } catch (error) {
            console.error('Media callback error:', error);
            await ctx.editMessageText('âŒ An error occurred');
        }
    }
    
    async showArticleSelectionForMedia(ctx, fileId) {
        const articles = await this.db.collection('news_articles')
            .find({})
            .sort({ published_date: -1 })
            .limit(10)
            .toArray();
        
        if (articles.length === 0) {
            return ctx.editMessageText('ðŸ“° No articles available');
        }
        
        await ctx.editMessageText(
            'ðŸ“° *Select Article for Media*\n\nChoose an article to attach this media to:',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: articles.map(article => [{
                        text: `ðŸ“° ${article.title.substring(0, 40)}...`,
                        callback_data: `attach_media:${fileId}:${article._id}`
                    }])
                }
            }
        );
    }
    
    async postMediaNow(ctx, fileId) {
        const media = await this.db.collection('user_media').findOne({ file_id: fileId });
        
        if (!media) {
            return ctx.editMessageText('âŒ Media not found');
        }
        
        const destinations = await this.db.collection('destinations').find({}).toArray();
        
        if (destinations.length === 0) {
            return ctx.editMessageText('ðŸ“ No destinations configured');
        }
        
        let successCount = 0;
        for (const dest of destinations) {
            try {
                const options = {
                    caption: media.caption || 'ðŸ“¸ Shared via Zone News Bot',
                    parse_mode: 'Markdown'
                };
                
                switch (media.type) {
                    case 'photo':
                        await ctx.telegram.sendPhoto(dest.id, media.file_id, options);
                        break;
                    case 'video':
                        await ctx.telegram.sendVideo(dest.id, media.file_id, options);
                        break;
                    case 'animation':
                        await ctx.telegram.sendAnimation(dest.id, media.file_id, options);
                        break;
                    case 'document':
                        await ctx.telegram.sendDocument(dest.id, media.file_id, options);
                        break;
                }
                successCount++;
            } catch (error) {
                console.error(`Failed to post media to ${dest.id}:`, error);
            }
        }
        
        await ctx.editMessageText(
            `âœ… *Media Posted!*\n\n` +
            `ðŸ“ Sent to ${successCount}/${destinations.length} destinations`,
            { parse_mode: 'Markdown' }
        );
    }
    
    async saveMediaForLater(ctx, fileId) {
        await this.db.collection('user_media').updateOne(
            { file_id: fileId },
            { $set: { status: 'saved', saved_at: new Date() } }
        );
        
        await ctx.editMessageText('ðŸ’¾ Media saved for later use');
    }
    
    async deleteMedia(ctx, fileId) {
        await this.db.collection('user_media').deleteOne({ file_id: fileId });
        await ctx.editMessageText('ðŸ—‘ï¸ Media deleted');
    }
    
    async attachMediaToArticle(ctx, fileId, articleId) {
        const { ObjectId } = require('mongodb');
        
        const media = await this.db.collection('user_media').findOne({ file_id: fileId });
        const article = await this.db.collection('news_articles').findOne({ _id: new ObjectId(articleId) });
        
        if (!media || !article) {
            return ctx.editMessageText('âŒ Media or article not found');
        }
        
        // Update article with media
        await this.db.collection('news_articles').updateOne(
            { _id: new ObjectId(articleId) },
            { 
                $set: { 
                    media_id: fileId,
                    media_type: media.type,
                    has_media: true
                }
            }
        );
        
        await ctx.editMessageText(
            `âœ… *Media Attached!*\n\n` +
            `ðŸ“° Article: ${article.title}\n` +
            `ðŸ“¸ Media: ${media.type}\n\n` +
            'Use /post to share this article with media',
            { parse_mode: 'Markdown' }
        );
    }
    
    async scheduleMediaPost(ctx, fileId) {
        // Show time selection for media post
        const timeOptions = [
            { label: 'In 30 minutes', minutes: 30 },
            { label: 'In 1 hour', minutes: 60 },
            { label: 'In 2 hours', minutes: 120 },
            { label: 'Tomorrow 9 AM', minutes: this.getMinutesUntilTime(9, 0) },
            { label: 'Tomorrow 6 PM', minutes: this.getMinutesUntilTime(18, 0) }
        ];
        
        await ctx.editMessageText(
            'â° *Schedule Media Post*\n\nWhen should this media be posted?',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: timeOptions.map(option => [{
                        text: option.label,
                        callback_data: `schedule_media:${fileId}:${option.minutes}`
                    }])
                }
            }
        );
    }
    
    async handleSettingsCallback(ctx, setting) {
        const { ObjectId } = require('mongodb');
        const userId = ctx.from.id;
        
        try {
            await ctx.answerCbQuery();
            
            switch (setting) {
                case 'city':
                    await this.showCitySelection(ctx);
                    break;
                case 'notifications':
                    await this.toggleNotifications(ctx, userId);
                    break;
                case 'language':
                    await this.showLanguageSelection(ctx);
                    break;
                case 'theme':
                    await this.showThemeSelection(ctx);
                    break;
                case 'profile':
                    await this.showUserProfile(ctx, userId);
                    break;
                case 'clear':
                    await this.confirmClearData(ctx, userId);
                    break;
                default:
                    if (setting.startsWith('setcity_')) {
                        const city = setting.replace('setcity_', '');
                        await this.setUserCity(ctx, userId, city);
                    } else if (setting.startsWith('setlang_')) {
                        const lang = setting.replace('setlang_', '');
                        await this.setUserLanguage(ctx, userId, lang);
                    } else if (setting.startsWith('settheme_')) {
                        const theme = setting.replace('settheme_', '');
                        await this.setUserTheme(ctx, userId, theme);
                    }
                    break;
            }
        } catch (error) {
            console.error('Settings callback error:', error);
            await ctx.editMessageText('âŒ An error occurred');
        }
    }
    
    async showCitySelection(ctx) {
        const cities = [
            ['Adelaide', 'Melbourne'],
            ['Sydney', 'Brisbane'],
            ['Perth', 'Darwin'],
            ['Hobart', 'Canberra'],
            ['Gold Coast', 'Newcastle']
        ];
        
        await ctx.editMessageText(
            'ðŸ“ *Select Your City*\n\n' +
            'Choose your city for localized news:',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: cities.map(row => 
                        row.map(city => ({
                            text: city,
                            callback_data: `settings:setcity_${city}`
                        }))
                    ).concat([[{ text: 'â¬…ï¸ Back', callback_data: 'back_to_settings' }]])
                }
            }
        );
    }
    
    async setUserCity(ctx, userId, city) {
        await this.db.collection('users').updateOne(
            { telegram_id: userId },
            { $set: { city: city, updated_at: new Date() } },
            { upsert: true }
        );
        
        await ctx.editMessageText(
            `âœ… City updated to *${city}*\n\n` +
            'You will now receive news relevant to your area.',
            { parse_mode: 'Markdown' }
        );
        
        setTimeout(() => {
            this.bot.telegram.sendMessage(ctx.chat.id, '/settings');
        }, 2000);
    }
    
    async toggleNotifications(ctx, userId) {
        const user = await this.db.collection('users').findOne({ telegram_id: userId });
        const currentStatus = user?.notifications !== false;
        const newStatus = !currentStatus;
        
        await this.db.collection('users').updateOne(
            { telegram_id: userId },
            { $set: { notifications: newStatus, updated_at: new Date() } },
            { upsert: true }
        );
        
        await ctx.editMessageText(
            `ðŸ”” Notifications ${newStatus ? 'enabled' : 'disabled'}`,
            {
                reply_markup: {
                    inline_keyboard: [[
                        { text: 'â¬…ï¸ Back to Settings', callback_data: 'back_to_settings' }
                    ]]
                }
            }
        );
    }
    
    async showLanguageSelection(ctx) {
        const languages = [
            ['ðŸ‡¬ðŸ‡§ English', 'en'],
            ['ðŸ‡ªðŸ‡¸ Spanish', 'es'],
            ['ðŸ‡«ðŸ‡· French', 'fr'],
            ['ðŸ‡©ðŸ‡ª German', 'de'],
            ['ðŸ‡®ðŸ‡¹ Italian', 'it'],
            ['ðŸ‡µðŸ‡¹ Portuguese', 'pt'],
            ['ðŸ‡·ðŸ‡º Russian', 'ru'],
            ['ðŸ‡¨ðŸ‡³ Chinese', 'zh'],
            ['ðŸ‡¯ðŸ‡µ Japanese', 'ja'],
            ['ðŸ‡°ðŸ‡· Korean', 'ko']
        ];
        
        await ctx.editMessageText(
            'ðŸŒ *Select Language*\n\n' +
            'Choose your preferred language:',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: languages.map(([name, code]) => [{
                        text: name,
                        callback_data: `settings:setlang_${code}`
                    }]).concat([[{ text: 'â¬…ï¸ Back', callback_data: 'back_to_settings' }]])
                }
            }
        );
    }
    
    async setUserLanguage(ctx, userId, lang) {
        await this.db.collection('users').updateOne(
            { telegram_id: userId },
            { $set: { language: lang, updated_at: new Date() } },
            { upsert: true }
        );
        
        const langNames = {
            en: 'English',
            es: 'Spanish',
            fr: 'French',
            de: 'German',
            it: 'Italian',
            pt: 'Portuguese',
            ru: 'Russian',
            zh: 'Chinese',
            ja: 'Japanese',
            ko: 'Korean'
        };
        
        await ctx.editMessageText(
            `âœ… Language set to *${langNames[lang] || lang}*`,
            { parse_mode: 'Markdown' }
        );
    }
    
    async showThemeSelection(ctx) {
        await ctx.editMessageText(
            'ðŸŽ¨ *Select Theme*\n\n' +
            'Choose your preferred theme:',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'â˜€ï¸ Light', callback_data: 'settings:settheme_light' }],
                        [{ text: 'ðŸŒ™ Dark', callback_data: 'settings:settheme_dark' }],
                        [{ text: 'ðŸŒ“ Auto', callback_data: 'settings:settheme_auto' }],
                        [{ text: 'â¬…ï¸ Back', callback_data: 'back_to_settings' }]
                    ]
                }
            }
        );
    }
    
    async setUserTheme(ctx, userId, theme) {
        await this.db.collection('users').updateOne(
            { telegram_id: userId },
            { $set: { theme: theme, updated_at: new Date() } },
            { upsert: true }
        );
        
        const themeEmoji = {
            light: 'â˜€ï¸',
            dark: 'ðŸŒ™',
            auto: 'ðŸŒ“'
        };
        
        await ctx.editMessageText(
            `âœ… Theme set to ${themeEmoji[theme]} ${theme}`,
            {
                reply_markup: {
                    inline_keyboard: [[
                        { text: 'â¬…ï¸ Back to Settings', callback_data: 'back_to_settings' }
                    ]]
                }
            }
        );
    }
    
    async showUserProfile(ctx, userId) {
        const [user, stats] = await Promise.all([
            this.db.collection('users').findOne({ telegram_id: userId }),
            this.db.collection('user_activity').findOne({ telegram_id: userId })
        ]);
        
        const savedCount = await this.db.collection('saved_articles')
            .countDocuments({ user_id: userId });
        
        const profileText = 
            'ðŸ‘¤ *Your Profile*\n\n' +
            `ðŸ†” ID: \`${userId}\`\n` +
            `ðŸ“ City: ${user?.city || 'Not set'}\n` +
            `ðŸŒ Language: ${user?.language || 'English'}\n` +
            `ðŸŽ¨ Theme: ${user?.theme || 'Auto'}\n` +
            `ðŸ”” Notifications: ${user?.notifications !== false ? 'On' : 'Off'}\n\n` +
            '*Activity:*\n' +
            `ðŸ“° Articles viewed: ${stats?.news_views || 0}\n` +
            `ðŸ’¾ Articles saved: ${savedCount}\n` +
            `ðŸ“… Member since: ${user?.created_at ? new Date(user.created_at).toLocaleDateString('en-AU') : 'Unknown'}`;
        
        await ctx.editMessageText(profileText, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [[
                    { text: 'â¬…ï¸ Back to Settings', callback_data: 'back_to_settings' }
                ]]
            }
        });
    }
    
    async confirmClearData(ctx, userId) {
        await ctx.editMessageText(
            'âš ï¸ *Clear All Data*\n\n' +
            'This will delete:\n' +
            'â€¢ All saved articles\n' +
            'â€¢ Your preferences\n' +
            'â€¢ Activity history\n\n' +
            'Are you sure?',
            {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: 'âœ… Yes, Clear', callback_data: 'confirm_clear_data' },
                            { text: 'âŒ Cancel', callback_data: 'back_to_settings' }
                        ]
                    ]
                }
            }
        );
    }
    
    async saveArticle(ctx, articleId) {
        const { ObjectId } = require('mongodb');
        const userId = ctx.from.id;
        
        try {
            await ctx.answerCbQuery();
            
            // Check if already saved
            const existing = await this.db.collection('saved_articles').findOne({
                user_id: userId,
                article_id: new ObjectId(articleId)
            });
            
            if (existing) {
                // Unsave
                await this.db.collection('saved_articles').deleteOne({
                    user_id: userId,
                    article_id: new ObjectId(articleId)
                });
                await ctx.answerCbQuery('ðŸ“Œ Article removed from saved', { show_alert: true });
            } else {
                // Save
                await this.db.collection('saved_articles').insertOne({
                    user_id: userId,
                    article_id: new ObjectId(articleId),
                    saved_at: new Date()
                });
                await ctx.answerCbQuery('ðŸ’¾ Article saved!', { show_alert: true });
            }
        } catch (error) {
            console.error('Save article error:', error);
            await ctx.answerCbQuery('âŒ Failed to save article', { show_alert: true });
        }
    }
    
    async shareArticle(ctx, articleId) {
        const { ObjectId } = require('mongodb');
        
        try {
            await ctx.answerCbQuery();
            
            const article = await this.db.collection('news_articles')
                .findOne({ _id: new ObjectId(articleId) });
            
            if (!article) {
                return ctx.answerCbQuery('Article not found', { show_alert: true });
            }
            
            const shareText = 
                `ðŸ“° ${article.title}\n\n` +
                `${article.summary || article.content?.substring(0, 200)}...\n\n` +
                `Read more: ${article.url || 'https://thezonenews.com'}\n\n` +
                `Shared via @ZoneNewsBot`;
            
            await ctx.reply(shareText, {
                reply_markup: {
                    inline_keyboard: [[
                        { text: 'ðŸ“¤ Share to Telegram', url: `https://t.me/share/url?url=${encodeURIComponent(article.url || 'https://thezonenews.com')}&text=${encodeURIComponent(article.title)}` }
                    ]]
                }
            });
        } catch (error) {
            console.error('Share article error:', error);
            await ctx.answerCbQuery('âŒ Failed to share', { show_alert: true });
        }
    }
    
    async handleComment(ctx, articleId) {
        const { ObjectId } = require('mongodb');
        
        try {
            await ctx.answerCbQuery();
            
            // Set state for comment input
            await this.db.collection('user_states').updateOne(
                { user_id: ctx.from.id },
                { 
                    $set: { 
                        state: 'awaiting_comment',
                        article_id: articleId,
                        created_at: new Date()
                    }
                },
                { upsert: true }
            );
            
            await ctx.reply(
                'ðŸ’¬ *Add Comment*\n\n' +
                'Type your comment below (max 500 characters):',
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        force_reply: true,
                        input_field_placeholder: 'Enter your comment...'
                    }
                }
            );
        } catch (error) {
            console.error('Comment error:', error);
            await ctx.answerCbQuery('âŒ Failed to add comment', { show_alert: true });
        }
    }
}

module.exports = CommandService;